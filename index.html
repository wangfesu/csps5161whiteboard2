<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å³æ™‚äº’å‹•æ•¸ä½ç™½æ¿V3.1(iconæ›´æ–°ç‰ˆ)</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fabric.js for canvas manipulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    
    <!-- PDF.js for PDF rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Specify workerSrc for pdf.js
      pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;
    </script>

    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        /* Custom styles */
        body { font-family: 'Inter', 'Noto Sans TC', sans-serif; }


        /* Style for selected tool */
        .tool-btn.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
        }
        /* Style for selected shape tool - yellow highlight */
        #shapes-btn.active {
            background-color: #eab308; /* yellow-500 */
            color: white;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #eab308;
        }
        /* Style for author names icon when active - red color */
        #toggle-author-names-btn.active #author-names-icon {
            stroke: #ef4444; /* red-500 */
        }
        /* Style for allow edit all icon when active - green color */
        #allow-edit-all-icon.text-green-500 {
            stroke: #22c55e; /* green-500 */
        }
        .pen-width-btn {
            background-color: #4b5563; /* gray-600 */
            color: white;
        }
        .pen-width-btn.active {
            background-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 2px white, 0 0 0 4px #3b82f6;
        }
        canvas {
            cursor: default;
        }
        /* Hide file inputs */
        #image-input, #pdf-input {
            display: none;
        }
        /* Custom scrollbar for PDF preview */
        .pdf-preview-grid::-webkit-scrollbar {
            width: 8px;
        }
        .pdf-preview-grid::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .pdf-preview-grid::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .pdf-preview-grid::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Style for code block in modal */
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-gray-100 overflow-hidden">

    <!-- Landing View: Role selection and session management -->
    <div id="landing-view" class="relative h-screen w-screen flex items-center justify-center p-4 bg-gradient-to-br from-blue-50 via-white to-green-50">
        <a href="https://filedn.com/laMtL9jmKf7JrDEQG0A6OPy/html/firebase-%E4%BA%92%E5%8B%95%E7%99%BD%E6%9D%BF/%E5%8D%B3%E6%99%82%E4%BA%92%E5%8B%95%E6%95%B8%E4%BD%8D%E7%99%BD%E6%9D%BF_%E6%95%99%E5%B8%AB%E5%BB%BA%E7%BD%AE%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8A.html" target="_blank" rel="noopener noreferrer" class="absolute top-4 right-4 bg-amber-500 text-white px-3 py-2 rounded-xl shadow-lg hover:bg-amber-600 transition-colors duration-300 text-sm font-bold flex items-center bg-opacity-90 backdrop-blur-sm z-10">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1.5"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
            <span>å»ºç½®æ“ä½œæ‰‹å†Š</span>
        </a>
        <div class="w-full max-w-6xl">
            <!-- Header -->
            <div class="text-center mb-12">
                <h1 class="text-5xl font-bold text-gray-800 mb-3">ğŸ“ å³æ™‚äº’å‹•æ•¸ä½ç™½æ¿</h1>
                <p class="text-xl text-gray-600">å°ˆç‚ºå¸«ç”Ÿè¨­è¨ˆçš„å”ä½œç©ºé–“ âœ¨</p>
            </div>

            <!-- Two Column Layout -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- Teacher Section -->
                <div class="bg-white rounded-2xl shadow-2xl p-8 border-4 border-blue-200 hover:border-blue-400 transition-all duration-300 transform hover:scale-105">
                    <div class="text-center mb-6">
                        <div class="text-6xl mb-4">ğŸ‘¨â€ğŸ«</div>
                        <h2 class="text-3xl font-bold text-blue-600 mb-2">æ•™å¸«å°ˆå€</h2>
                        <p class="text-gray-500">å»ºç«‹æˆ–é€²å…¥æ‚¨çš„æ•™å­¸ç™½æ¿</p>
                    </div>
                    <div id="teacher-login-step1" class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ” æ•™å¸«å¯†ç¢¼</label>
                            <input id="teacher-password" type="password" placeholder="è«‹è¼¸å…¥æ•™å¸«å¯†ç¢¼" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                        </div>
                        <button id="teacher-password-submit-btn" class="w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white py-3 rounded-lg hover:from-blue-600 hover:to-blue-700 transition font-bold text-lg shadow-md hover:shadow-lg">
                            ä¸‹ä¸€æ­¥
                        </button>
                    </div>
                    <div id="teacher-login-step2" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ“‚ é¸æ“‡ç¾æœ‰ç™½æ¿</label>
                            <div class="flex items-center space-x-2">
                                <select id="existing-sessions-dropdown" class="flex-grow px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition">
                                    <option value="">-- è«‹é¸æ“‡æˆ–æ–¼ä¸‹æ–¹è¼¸å…¥æ–°ID --</option>
                                    <!-- Options will be populated by JS -->
                                </select>
                                <button id="delete-selected-session-btn" class="hidden p-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition" title="åˆªé™¤é¸å–çš„ç™½æ¿">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                                </button>
                            </div>
                        </div>
                        <div class="text-center text-gray-500 text-sm">æˆ–</div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">âœï¸ è¼¸å…¥æ–°ç™½æ¿ID (æˆ–ç•™ç©ºè‡ªå‹•ç”Ÿæˆ)</label>
                            <input id="session-id-teacher" type="text" placeholder="è‡ªè¨‚IDæˆ–ç•™ç©º" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                        </div>
                        <button id="enter-whiteboard-btn" class="w-full bg-gradient-to-r from-green-600 to-green-700 text-white py-4 rounded-lg hover:from-green-700 hover:to-green-800 transition font-bold text-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                            ğŸš€ é€²å…¥ç™½æ¿
                        </button>
                        <div class="relative my-4">
                            <div class="absolute inset-0 flex items-center" aria-hidden="true">
                                <div class="w-full border-t border-gray-300"></div>
                            </div>
                            <div class="relative flex justify-center">
                                <span class="bg-white px-2 text-sm text-gray-500">å±éšªæ“ä½œ</span>
                            </div>
                        </div>
                        <button id="close-session-btn" class="w-full bg-gradient-to-r from-red-700 to-red-800 text-white py-3 rounded-lg hover:from-red-800 hover:to-red-900 transition font-bold text-lg shadow-md hover:shadow-lg flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>
                            <span>æ¸…ç©ºæ•´å€‹è³‡æ–™åº« (åˆªé™¤æ‰€æœ‰ç™½æ¿)</span>
                        </button>
                    </div>
                </div>

                <!-- Student Section -->
                <div class="bg-white rounded-2xl shadow-2xl p-8 border-4 border-green-200 hover:border-green-400 transition-all duration-300 transform hover:scale-105">
                    <div class="text-center mb-6">
                        <div class="text-6xl mb-4">ğŸ‘¨â€ğŸ“</div>
                        <h2 class="text-3xl font-bold text-green-600 mb-2">å­¸ç”Ÿå°ˆå€</h2>
                        <p class="text-gray-500">åŠ å…¥è€å¸«çš„æ•™å­¸ç™½æ¿</p>
                    </div>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ‘¤ æ‚¨çš„å§“å</label>
                            <input id="student-name" type="text" placeholder="è«‹è¼¸å…¥æ‚¨çš„å§“å" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold text-gray-700 mb-2">ğŸ”‘ ç™½æ¿ID</label>
                            <input id="session-id-student" type="text" placeholder="è«‹è¼¸å…¥è€å¸«æä¾›çš„ID" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 focus:border-transparent transition">
                        </div>
                        <button id="join-session-btn" class="w-full bg-gradient-to-r from-green-600 to-green-700 text-white py-4 rounded-lg hover:from-green-700 hover:to-green-800 transition font-bold text-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1">
                            âœ… åŠ å…¥ç™½æ¿
                        </button>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <div class="text-center mt-8 space-y-2">
                <button id="show-setup-btn" class="text-sm text-gray-500 hover:text-blue-600 underline transition">
                    â“ éœ€è¦å¹«åŠ©ï¼Ÿé»æ­¤æŸ¥çœ‹ Firebase è¨­å®šèªªæ˜
                </button>
                <div class="text-gray-500 text-sm">
                    Made with â¤ï¸ by <a href="https://kentxchang.blogspot.tw" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:text-blue-700 font-semibold underline">é˜¿å‰›è€å¸« V3.1</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Whiteboard View -->
    <div id="whiteboard-view" class="hidden h-screen w-screen relative">
        <!-- Pages Toolbar -->
        <div id="pages-toolbar" class="fixed top-1/2 -translate-y-1/2 left-4 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white p-2 rounded-xl shadow-lg flex flex-col items-center space-y-2 z-20 max-h-[80vh] overflow-y-auto">
            <!-- Pages will be rendered here by JS -->
        </div>

        <canvas id="whiteboard-canvas"></canvas>
        
        <!-- Teacher Lock Message -->
        <div id="lock-message" class="hidden fixed bottom-16 left-1/2 -translate-x-1/2 bg-red-600 text-white px-4 py-2 rounded-lg shadow-lg z-30 text-lg font-bold animate-pulse">
            æ•™å¸«é–å®šä¸­...
        </div>

        <!-- Floating Toolbar -->
        <div id="toolbar" class="toolbar fixed bottom-4 left-1/2 -translate-x-1/2 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white p-2 rounded-xl shadow-lg flex flex-nowrap items-center space-x-1 z-20">
            <!-- Basic Tools -->
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="pan" title="ç§»å‹•ç•«å¸ƒ (H)">
                <i class="fas fa-arrows-up-down-left-right" style="font-size: 24px;"></i>
            </button>
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="select" title="é¸å–/ç§»å‹• (V)">
                <i class="fas fa-mouse-pointer" style="font-size: 24px;"></i>
            </button>
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="pen" title="ç•«ç­† (P)">
                <i class="fas fa-pencil-alt" style="font-size: 24px;"></i>
            </button>
            <div class="relative">
                <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" id="shapes-btn" title="åœ–å½¢ (S)">
                    <i class="fas fa-shapes" style="font-size: 24px;"></i>
                </button>
                <div id="shape-options" class="hidden absolute bottom-full mb-2 bg-gray-800 bg-opacity-90 backdrop-blur-sm rounded-lg p-1 flex flex-col space-y-1">
                    <button class="shape-btn p-2 rounded-lg hover:bg-gray-600" data-tool="arrow" title="ç®­é ­">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                    </button>
                    <button class="shape-btn p-2 rounded-lg hover:bg-gray-600" data-tool="circle" title="åœ“å½¢">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>
                    </button>
                    <button class="shape-btn p-2 rounded-lg hover:bg-gray-600" data-tool="rect" title="çŸ©å½¢">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>
                    </button>
                </div>
            </div>
            <div id="pen-options" class="hidden flex items-center space-x-2 pl-2">
                <input type="color" id="pen-color" value="#3b82f6" class="w-8 h-8 rounded-full cursor-pointer bg-transparent border-none" title="ç•«ç­†é¡è‰²">
                <button data-width="5" class="pen-width-btn w-6 h-6 rounded-lg flex items-center justify-center text-sm font-semibold">5</button>
                <button data-width="10" class="pen-width-btn w-6 h-6 rounded-lg flex items-center justify-center text-sm font-semibold">10</button>
                <button data-width="20" class="pen-width-btn w-6 h-6 rounded-lg flex items-center justify-center text-sm font-semibold">20</button>
            </div>

            <div class="w-px h-8 bg-gray-600"></div>

            <!-- Content Tools -->
            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="note" title="ä¾¿åˆ©è²¼ (N)">
                <i class="fas fa-sticky-note" style="font-size: 24px;"></i>
            </button>
            <div id="note-options" class="hidden items-center space-x-1 pl-1">
                <button data-color="#FFFBEB" class="w-6 h-6 rounded-full bg-yellow-100 border-2 border-white" title="é»ƒè‰²ä¾¿åˆ©è²¼"></button>
                <button data-color="#EFF6FF" class="w-6 h-6 rounded-full bg-blue-100 border-2 border-white" title="è—è‰²ä¾¿åˆ©è²¼"></button>
                <button data-color="#FCE7F3" class="w-6 h-6 rounded-full bg-pink-100 border-2 border-white" title="ç²‰è‰²ä¾¿åˆ©è²¼"></button>
                <button data-color="#F0FDF4" class="w-6 h-6 rounded-full bg-green-100 border-2 border-white" title="ç¶ è‰²ä¾¿åˆ©è²¼"></button>
            </div>

            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" id="upload-image-btn" title="æ’å…¥åœ–ç‰‡ (I)">
                <i class="fas fa-image" style="font-size: 24px;"></i>
            </button>
            <input type="file" id="image-input" accept="image/*">

            <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" id="upload-pdf-btn" title="æ’å…¥PDF (F)">
                <i class="fas fa-file-pdf" style="font-size: 24px;"></i>
            </button>
            <input type="file" id="pdf-input" accept=".pdf">

            <div class="w-px h-8 bg-gray-600"></div>

            <!-- Action Tools -->
             <button class="tool-btn p-3 rounded-lg hover:bg-gray-700" data-tool="delete" title="åˆªé™¤é¸å– (Delete)">
                <i class="fas fa-trash" style="font-size: 24px;"></i>
            </button>

            <!-- Teacher Only Tools -->
            <div id="teacher-tools" class="hidden flex items-center">
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                <button id="lock-students-btn" class="p-3 rounded-lg hover:bg-gray-700 flex items-center" title="é–å®š/è§£é–å­¸ç”Ÿå·¥å…·">
                    <svg id="lock-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                </button>
                <button id="allow-edit-all-btn" class="p-3 rounded-lg hover:bg-gray-700 flex items-center" title="é–‹æ”¾/é™åˆ¶å­¸ç”Ÿç·¨è¼¯æ‰€æœ‰ç‰©ä»¶">
                    <svg id="allow-edit-all-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button id="toggle-author-names-btn" class="p-3 rounded-lg hover:bg-gray-700 flex items-center" title="é¡¯ç¤º/éš±è—ä½œè€…å§“å">
                    <svg id="author-names-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                </button>
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                <button id="export-menu-btn" class="p-3 rounded-lg text-green-500 hover:bg-green-500 hover:text-white" title="åŒ¯å…¥/åŒ¯å‡º/ä¸‹è¼‰">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                </button>
                <input type="file" id="json-input" accept=".json" style="display: none;">
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                <button id="leave-session-btn" class="p-3 rounded-lg text-yellow-500 hover:bg-yellow-500 hover:text-white" title="é›¢é–‹ç™½æ¿ï¼ˆä¸åˆªé™¤è³‡æ–™ï¼‰">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                </button>
            </div>
        </div>

        <!-- Session Info Container -->
        <div class="absolute top-4 left-4 flex space-x-2 z-10">
            <div id="session-info" class="bg-white bg-opacity-80 backdrop-blur-sm px-4 py-2 rounded-lg shadow-md cursor-pointer hover:bg-opacity-100 hover:shadow-lg transition-all" title="é»æ“Šåˆ‡æ›ç™½æ¿ï¼ˆåƒ…é™æ•™å¸«ï¼‰">
                ç™½æ¿ID: <span id="session-id-display" class="font-bold text-blue-600"></span>
            </div>
             <div id="student-name-display-container" class="hidden bg-white bg-opacity-80 backdrop-blur-sm px-4 py-2 rounded-lg shadow-md">
                å§“å: <span id="student-name-display" class="font-bold text-purple-600"></span>
            </div>
             <div id="participant-info" class="bg-white bg-opacity-80 backdrop-blur-sm px-4 py-2 rounded-lg shadow-md">
                <span id="participant-display" class="font-semibold text-green-600">ç·šä¸Šäººæ•¸: 0</span>
            </div>
        </div>
        
        <!-- Author Names Toggle Button is now integrated into the main toolbar -->


        <!-- Zoom Control -->
        <div id="zoom-control" class="absolute top-4 right-4 bg-gray-800 bg-opacity-90 backdrop-blur-sm text-white p-2 rounded-xl shadow-lg z-20 flex items-center space-x-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
            <input type="range" id="zoom-slider" min="0.1" max="4" step="0.01" value="1" class="w-32">
            <span id="zoom-label" class="text-sm w-12 text-center">100%</span>
        </div>

        <!-- Context Menu -->
        <div id="context-menu" class="hidden fixed bg-white rounded-lg shadow-xl border border-gray-200 py-2 z-50" style="min-width: 150px;">
            <button id="context-change-color" class="hidden w-full px-4 py-2 text-left hover:bg-gray-100 flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>
                <span>è¨­å®šèƒŒæ™¯è‰²</span>
            </button>
            <button id="context-duplicate-text" class="hidden w-full px-4 py-2 text-left hover:bg-gray-100 flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                <span>å†è£½ä¾¿åˆ©è²¼</span>
            </button>
            <button id="context-duplicate-image" class="hidden w-full px-4 py-2 text-left hover:bg-gray-100 flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2 2v1"></path></svg>
                <span>å†è£½åœ–ç‰‡</span>
            </button>
        </div>

    </div>

    <!-- Participant List Modal -->
    <div id="participant-list-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[70] p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md h-[70vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold">ç·šä¸Šåƒèˆ‡è€…</h2>
                <button id="close-participant-list-modal" class="text-gray-500 hover:text-gray-800 text-3xl font-bold leading-none">&times;</button>
            </div>
            <div id="participant-list-container" class="p-4 flex-grow overflow-y-auto space-y-2">
                <!-- Participant list will be rendered here -->
            </div>
            <div class="p-4 border-t flex justify-end">
                <button id="refresh-participant-list-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">é‡æ–°æ•´ç†</button>
            </div>
        </div>
    </div>

    <!-- Firebase Setup Modal -->
    <div id="setup-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-60 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-3xl p-8 space-y-4 relative max-h-[90vh] overflow-y-auto">
            <button id="close-setup-btn" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 text-3xl font-bold leading-none">&times;</button>
            <h2 class="text-2xl font-bold text-center text-red-600">å®Œæ•´ Firebase è¨­å®šæ•™å­¸</h2>
            <p class="text-center text-gray-600">è«‹ä¾ç…§ä»¥ä¸‹è©³ç´°æ­¥é©Ÿï¼Œä¸€æ­¥æ­¥å®Œæˆè¨­å®šï¼Œè®“æ‚¨çš„æ•¸ä½ç™½æ¿é †åˆ©é‹ä½œã€‚</p>
            
            <div class="text-sm space-y-4 text-left">
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬ä¸€æ­¥ï¼šå»ºç«‹ Firebase å°ˆæ¡ˆ</h3>
                    <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>å‰å¾€ <a href="https://console.firebase.google.com/" target="_blank" class="text-blue-600 underline">Firebase æ§åˆ¶å°</a> ä¸¦ç™»å…¥æ‚¨çš„ Google å¸³è™Ÿã€‚</li>
                        <li>é»æ“Šã€Œå»ºç«‹å°ˆæ¡ˆã€(Create a project)ã€‚</li>
                        <li>ç‚ºæ‚¨çš„å°ˆæ¡ˆå‘½å (ä¾‹å¦‚ï¼š`my-whiteboard-app`)ï¼Œç„¶å¾Œé»æ“Šã€Œç¹¼çºŒã€ã€‚</li>
                        <li>æ‚¨å¯ä»¥é¸æ“‡**é—œé–‰** "ç‚ºé€™å€‹å°ˆæ¡ˆå•Ÿç”¨ Google Analytics" (Enable Google Analytics)ï¼Œå› ç‚ºæ­¤å°ˆæ¡ˆç”¨ä¸åˆ°ã€‚é»æ“Šã€Œå»ºç«‹å°ˆæ¡ˆã€ã€‚</li>
                    </ol>
                </div>
    
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬äºŒæ­¥ï¼šåœ¨å°ˆæ¡ˆä¸­æ–°å¢ã€Œç¶²é æ‡‰ç”¨ã€ä¸¦å–å¾—è¨­å®šç¢¼</h3>
                    <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>å°ˆæ¡ˆå»ºç«‹å¾Œï¼Œåœ¨å°ˆæ¡ˆä¸»æ§å°é é¢ï¼Œé»æ“Šã€Œç¶²é ã€åœ–ç¤º (<code class="bg-gray-200 px-1 rounded">&lt;/&gt;</code>)ã€‚</li>
                        <li>ç‚ºæ‚¨çš„æ‡‰ç”¨ç¨‹å¼å–ä¸€å€‹æš±ç¨± (ä¾‹å¦‚ï¼š`ç™½æ¿å‰ç«¯`)ï¼Œç„¶å¾Œé»æ“Šã€Œè¨»å†Šæ‡‰ç”¨ç¨‹å¼ã€ã€‚</li>
                        <li>è¨»å†Šå¾Œï¼Œæ‚¨æœƒçœ‹åˆ°ã€Œå°‡ Firebase SDK æ–°å¢è‡³æ‚¨çš„æ‡‰ç”¨ç¨‹å¼ã€çš„ç•«é¢ã€‚è«‹æ‰¾åˆ° <code class="bg-gray-200 px-1 rounded">firebaseConfig</code> ç‰©ä»¶ã€‚</li>
                        <li><strong>(é—œéµæ­¥é©Ÿ)</strong> è¤‡è£½æ•´å€‹ <code class="bg-gray-200 px-1 rounded">const firebaseConfig = { ... };</code> ç¨‹å¼ç¢¼å€å¡Šã€‚</li>
                        <li>æ‰“é–‹ <code>whiteboard.html</code> æª”æ¡ˆï¼Œæ‰¾åˆ° <code>&lt;script type="module"&gt;</code> å€å¡Šï¼Œå°‡æ‚¨å‰›å‰›è¤‡è£½çš„å…§å®¹ï¼Œå®Œæ•´åœ°è²¼ä¸Šä¾†å–ä»£æ‰é è¨­çš„ä½”ä½ç¬¦ã€‚</li>
                    </ol>
                </div>
    
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬ä¸‰æ­¥ï¼šè¨­å®š Firestore è³‡æ–™åº«</h3>
                    <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>åœ¨ Firebase æ§åˆ¶å°å·¦å´é¸å–®ï¼Œé»æ“Šã€Œå»ºæ§‹ã€(Build) > ã€ŒFirestore Databaseã€ã€‚</li>
                        <li>é»æ“Šã€Œå»ºç«‹è³‡æ–™åº«ã€(Create database)ã€‚</li>
                        <li>é¸æ“‡ã€Œä»¥**æ¸¬è©¦æ¨¡å¼**é–‹å§‹ã€(Start in test mode)ï¼Œç„¶å¾Œé»æ“Šã€Œä¸‹ä¸€æ­¥ã€ã€‚</li>
                        <li>é¸æ“‡é›¢æ‚¨æœ€è¿‘çš„ Cloud Firestore ä½ç½® (ä¾‹å¦‚ï¼š`asia-east1` (å°ç£) æˆ– `asia-northeast1` (æ±äº¬))ï¼Œç„¶å¾Œé»æ“Šã€Œå•Ÿç”¨ã€ã€‚</li>
                    </ol>
                </div>
                
                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬å››æ­¥ï¼šå•Ÿç”¨ã€ŒåŒ¿åç™»å…¥ã€</h3>
                     <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>åœ¨ Firebase æ§åˆ¶å°å·¦å´é¸å–®ï¼Œé»æ“Šã€Œå»ºæ§‹ã€(Build) > ã€ŒAuthenticationã€ã€‚</li>
                        <li>é»æ“Šã€Œé–‹å§‹ä½¿ç”¨ã€(Get started)ã€‚</li>
                        <li>åœ¨æ–°é é¢ä¸­ï¼Œé¸æ“‡ã€Œç™»å…¥æ–¹å¼ã€(Sign-in method) é ç±¤ã€‚</li>
                        <li>åœ¨ä¾›æ‡‰å•†æ¸…å–®ä¸­ï¼Œæ‰¾åˆ°ã€ŒåŒ¿åã€(Anonymous) ä¸¦é»æ“Šå®ƒã€‚</li>
                        <li>å°‡é–‹é—œè¨­å®šç‚ºã€Œå•Ÿç”¨ã€(Enable)ï¼Œç„¶å¾Œé»æ“Šã€Œå„²å­˜ã€ã€‚</li>
                    </ol>
                </div>

                <div>
                    <h3 class="font-bold text-lg text-gray-800">ç¬¬äº”æ­¥ï¼šæ›´æ–°è³‡æ–™åº«å®‰å…¨è¦å‰‡ (é•·æœŸä½¿ç”¨)</h3>
                     <ol class="list-decimal list-inside bg-gray-50 p-4 rounded-lg mt-2 space-y-2">
                        <li>åœ¨ã€ŒFirestore Databaseã€é é¢ï¼Œé»æ“Šä¸Šæ–¹çš„ã€Œè¦å‰‡ã€(Rules) é ç±¤ã€‚</li>
                        <li>å°‡ç·¨è¼¯å™¨ä¸­ç¾æœ‰çš„æ‰€æœ‰æ–‡å­—åˆªé™¤ã€‚</li>
                        <li>è¤‡è£½ä¸‹æ–¹çš„ç¨‹å¼ç¢¼ï¼Œä¸¦å®Œæ•´è²¼åˆ°ç·¨è¼¯å™¨ä¸­ã€‚é€™å°‡å…è¨±æ‰€æœ‰å·²ç™»å…¥çš„ä½¿ç”¨è€…ï¼ˆåŒ…å«åŒ¿åç™»å…¥ï¼‰å­˜å–ç™½æ¿è³‡æ–™ï¼Œç¢ºä¿ç™½æ¿åœ¨30å¤©å¾Œä»å¯æ­£å¸¸ä½¿ç”¨ã€‚</li>
                        <li class="list-none">
                            <pre class="code-block"><code>rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /sessions/{sessionId} {
      // å…è¨±å·²ç™»å…¥ç”¨æˆ¶è®€å–ã€å»ºç«‹ã€æ›´æ–°ã€åˆªé™¤sessionæ–‡ä»¶
      allow read, create, update, delete: if request.auth != null;

      // å…è¨±å·²ç™»å…¥ç”¨æˆ¶æ“ä½œæ‰€æœ‰å­é›†åˆï¼ˆparticipants, canvasObjectsç­‰ï¼‰
      match /{document=**} {
        allow read, create, update, delete: if request.auth != null;
      }
    }
  }
}</code></pre>
                        </li>
                        <li>é»æ“Šã€Œç™¼å¸ƒã€(Publish) æŒ‰éˆ•ä¾†å„²å­˜æ‚¨çš„æ–°è¦å‰‡ã€‚</li>
                    </ol>
                </div>
            </div>
             <div class="text-xs text-gray-500 text-center pt-4 border-t">
                <p>å®Œæˆä»¥ä¸Šäº”å€‹æ­¥é©Ÿå¾Œï¼Œè«‹é‡æ–°æ•´ç† <code>whiteboard.html</code> é é¢å³å¯é–‹å§‹ä½¿ç”¨ï¼</p>
            </div>
        </div>
    </div>
    
    <!-- PDF Preview Modal -->
    <div id="pdf-preview-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl h-[90vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold">é¸æ“‡è¦æ’å…¥çš„ PDF é é¢</h2>
                <button id="close-pdf-modal" class="text-gray-500 hover:text-gray-800">&times;</button>
            </div>
            <div id="pdf-preview-grid" class="p-4 flex-grow overflow-y-auto grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                <!-- PDF pages will be rendered here -->
            </div>
            <div class="p-4 border-t flex justify-end">
                <button id="insert-pdf-pages-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700">æ’å…¥é¸å–é é¢</button>
            </div>
        </div>
    </div>

    <!-- Switch Canvas Modal -->
    <div id="switch-canvas-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md flex flex-col max-h-[70vh]">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold">åˆ‡æ›ç™½æ¿</h2>
                <button id="close-switch-canvas-modal" class="text-gray-500 hover:text-gray-800 text-3xl font-bold leading-none">&times;</button>
            </div>
            <div id="canvas-list-container" class="p-4 flex-grow overflow-y-auto space-y-2">
                <!-- Canvas list will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Message Overlay -->
    <div id="message-overlay" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-sm text-center p-6 space-y-4">
            <p id="message-text" class="text-lg text-gray-800"></p>
            <button id="message-ok-btn" class="bg-blue-600 text-white px-8 py-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">ç¢ºå®š</button>
        </div>
    </div>

    <!-- Confirm Overlay -->
    <div id="confirm-overlay" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-[80] p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md text-center p-6 space-y-4">
            <div class="flex justify-center mb-4">
                <svg class="w-16 h-16 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
            </div>
            <h3 id="confirm-title" class="text-xl font-bold text-gray-800 mb-2"></h3>
            <p id="confirm-text" class="text-gray-600 mb-6"></p>
            <div class="flex space-x-3 justify-center">
                <button id="confirm-cancel-btn" class="px-6 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400">å–æ¶ˆ</button>
                <button id="confirm-ok-btn" class="px-6 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">ç¢ºèª</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="hidden fixed inset-0 bg-white bg-opacity-75 flex items-center justify-center z-50">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500 mx-auto"></div>
            <p id="loading-text" class="mt-4 text-lg font-semibold">è™•ç†ä¸­...</p>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast-notification" class="hidden fixed top-20 left-1/2 transform -translate-x-1/2 bg-blue-600 text-white px-6 py-3 rounded-lg shadow-lg z-70 max-w-md text-center">
        <p id="toast-text"></p>
    </div>

    <!-- Page Selector Modal -->
    <div id="page-selector-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-md p-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4">é¸æ“‡è¦è²¼ä¸Šçš„åˆ†é </h3>
            <div id="page-selector-list" class="max-h-96 overflow-y-auto space-y-2 mb-6">
                <!-- Page buttons will be rendered here -->
            </div>
            <div class="flex justify-end">
                <button id="page-selector-cancel" class="px-6 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="color-picker-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 p-4">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-sm p-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4">é¸æ“‡ä¾¿åˆ©è²¼èƒŒæ™¯è‰²</h3>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <button data-color="#FFFBEB" class="h-24 rounded-lg border-4 border-transparent hover:border-blue-500 transition-all" style="background-color: #FFFBEB;">
                    <span class="text-gray-700 font-medium">é»ƒè‰²</span>
                </button>
                <button data-color="#EFF6FF" class="h-24 rounded-lg border-4 border-transparent hover:border-blue-500 transition-all" style="background-color: #EFF6FF;">
                    <span class="text-gray-700 font-medium">è—è‰²</span>
                </button>
                <button data-color="#FCE7F3" class="h-24 rounded-lg border-4 border-transparent hover:border-blue-500 transition-all" style="background-color: #FCE7F3;">
                    <span class="text-gray-700 font-medium">ç²‰è‰²</span>
                </button>
                <button data-color="#F0FDF4" class="h-24 rounded-lg border-4 border-transparent hover:border-blue-500 transition-all" style="background-color: #F0FDF4;">
                    <span class="text-gray-700 font-medium">ç¶ è‰²</span>
                </button>
            </div>
            <div class="flex justify-end">
                <button id="color-picker-cancel" class="px-6 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- Export Options Modal -->
    <div id="export-options-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-60 p-4">
        <div class="bg-white rounded-lg shadow-xl p-6">
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">é¸æ“‡æ“ä½œ</h3>
            <div class="flex gap-4 mb-6">
                <!-- ä¸‹è¼‰ PDF -->
                <button id="download-pdf-btn" class="w-40 h-40 bg-purple-500 text-white rounded-lg hover:bg-purple-600 flex flex-col items-center justify-center space-y-3 transition-all transform hover:scale-105 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><polyline points="9 15 12 18 15 15"></polyline></svg>
                    <span class="text-lg font-semibold">ä¸‹è¼‰ PDF</span>
                </button>

                <!-- åŒ¯å‡º JSON -->
                <button id="export-json-btn" class="w-40 h-40 bg-green-500 text-white rounded-lg hover:bg-green-600 flex flex-col items-center justify-center space-y-3 transition-all transform hover:scale-105 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    <span class="text-lg font-semibold">åŒ¯å‡º JSON</span>
                </button>

                <!-- åŒ¯å…¥ JSON -->
                <button id="import-json-btn" class="w-40 h-40 bg-blue-500 text-white rounded-lg hover:bg-blue-600 flex flex-col items-center justify-center space-y-3 transition-all transform hover:scale-105 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                    <span class="text-lg font-semibold">åŒ¯å…¥ JSON</span>
                </button>
            </div>
            <div class="flex justify-center">
                <button id="export-options-cancel" class="px-8 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-400 transition-all">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, addDoc, collection, onSnapshot, updateDoc, deleteDoc, runTransaction, serverTimestamp, getDocs, writeBatch, query, where } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.17.1/firebase-auth.js";

        // --- Custom Message Overlay ---
        function showMessage(message) {
            const overlay = document.getElementById('message-overlay');
            const text = document.getElementById('message-text');
            if (overlay && text) {
                text.textContent = message;
                overlay.classList.remove('hidden');
            } else {
                // Fallback to native alert if UI is not ready
                console.warn("showMessage UI not found, falling back to native alert.");
                alert(message);
            }
        }

        // --- Toast Notification (non-blocking) ---
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast-notification');
            const text = document.getElementById('toast-text');
            if (toast && text) {
                text.textContent = message;
                toast.classList.remove('hidden');

                // Auto-hide after duration
                setTimeout(() => {
                    toast.classList.add('hidden');
                }, duration);
            }
        }

        // --- Page Selector Modal ---
        function showPageSelector(totalPages, currentPageNum) {
            return new Promise((resolve) => {
                const modal = document.getElementById('page-selector-modal');
                const listContainer = document.getElementById('page-selector-list');
                const cancelBtn = document.getElementById('page-selector-cancel');

                if (!modal || !listContainer) {
                    console.error('Page selector modal not found');
                    resolve(null);
                    return;
                }

                // Clear previous content
                listContainer.innerHTML = '';

                // Create page buttons
                for (let i = 1; i <= totalPages; i++) {
                    const pageBtn = document.createElement('button');
                    pageBtn.className = 'w-full px-4 py-3 text-left rounded-lg font-medium transition-colors';

                    if (i === currentPageNum) {
                        pageBtn.className += ' bg-blue-500 text-white';
                        pageBtn.innerHTML = `åˆ†é  ${i} <span class="text-sm">(ç›®å‰åˆ†é )</span>`;
                    } else {
                        pageBtn.className += ' bg-gray-100 hover:bg-gray-200 text-gray-800';
                        pageBtn.innerHTML = `åˆ†é  ${i}`;
                    }

                    pageBtn.addEventListener('click', () => {
                        modal.classList.add('hidden');
                        resolve(i);
                    });

                    listContainer.appendChild(pageBtn);
                }

                // Cancel button
                const cancelHandler = () => {
                    modal.classList.add('hidden');
                    resolve(null);
                };
                cancelBtn.removeEventListener('click', cancelHandler);
                cancelBtn.addEventListener('click', cancelHandler);

                // Show modal
                modal.classList.remove('hidden');
            });
        }

        // --- Color Picker Modal ---
        function showColorPicker() {
            return new Promise((resolve) => {
                const modal = document.getElementById('color-picker-modal');
                const colorButtons = modal.querySelectorAll('button[data-color]');
                const cancelBtn = document.getElementById('color-picker-cancel');

                if (!modal) {
                    console.error('Color picker modal not found');
                    resolve(null);
                    return;
                }

                // Add click handlers to color buttons
                const colorHandlers = [];
                colorButtons.forEach(btn => {
                    const handler = () => {
                        const color = btn.dataset.color;
                        modal.classList.add('hidden');
                        resolve(color);
                    };
                    colorHandlers.push({ btn, handler });
                    btn.addEventListener('click', handler);
                });

                // Cancel button
                const cancelHandler = () => {
                    modal.classList.add('hidden');
                    // Clean up event listeners
                    colorHandlers.forEach(({ btn, handler }) => {
                        btn.removeEventListener('click', handler);
                    });
                    resolve(null);
                };
                cancelBtn.addEventListener('click', cancelHandler, { once: true });

                // Show modal
                modal.classList.remove('hidden');
            });
        }

        // --- Custom Confirm Overlay ---
        function showConfirm(title, message) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('confirm-overlay');
                const titleEl = document.getElementById('confirm-title');
                const textEl = document.getElementById('confirm-text');
                const okBtn = document.getElementById('confirm-ok-btn');
                const cancelBtn = document.getElementById('confirm-cancel-btn');

                if (overlay && titleEl && textEl && okBtn && cancelBtn) {
                    titleEl.textContent = title;
                    textEl.textContent = message;
                    overlay.classList.remove('hidden');

                    // Create one-time event listeners
                    const handleOk = () => {
                        overlay.classList.add('hidden');
                        okBtn.removeEventListener('click', handleOk);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(true);
                    };

                    const handleCancel = () => {
                        overlay.classList.add('hidden');
                        okBtn.removeEventListener('click', handleOk);
                        cancelBtn.removeEventListener('click', handleCancel);
                        resolve(false);
                    };

                    okBtn.addEventListener('click', handleOk);
                    cancelBtn.addEventListener('click', handleCancel);
                } else {
                    // Fallback to native confirm if UI is not ready
                    console.warn("showConfirm UI not found, falling back to native confirm.");
                    resolve(confirm(title + '\n\n' + message));
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Set up the 'OK' button listener for our custom message box
            const okBtn = document.getElementById('message-ok-btn');
            if (okBtn) {
                okBtn.addEventListener('click', () => {
                    const overlay = document.getElementById('message-overlay');
                    if(overlay) overlay.classList.add('hidden');
                });
            }
        });

        // --- DOM Elements ---
        const landingView = document.getElementById('landing-view');
        const whiteboardView = document.getElementById('whiteboard-view');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const setupModal = document.getElementById('setup-modal');

        // --- Global State ---
        let firebaseApp, db, auth;
        let sessionId, userRole;
        let currentPage = 1;
        const unsubscribes = [];
        let unsubscribePageObjects; // For page-specific objects listener
        let isLocked = false;
        let isCurrentUserIndividuallyLocked = false;
        let showAuthorNames = false;
        let allowStudentEditAll = false; // Allow students to edit all objects
        const participantDataMap = new Map(); // Map<uid, {name, role, isLockedByTeacher}>
        let isDrawing = false, isPanning = false, lastPointer = { x: 0, y: 0 };
        let touchStartTime = 0; // Track when first touch started
        let initialTouchCount = 0; // Track initial touch count
        let remoteUpdateGuard = false; // Prevent feedback loops
        const fabricObjects = new Map(); // Maps Firestore docId to Fabric object
        const pageViewStates = new Map(); // Maps page number to {zoom, viewportTransform}

        // Inactivity timer for students (30 minutes)
        let inactivityTimer = null;
        const INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes in milliseconds

        // --- Firebase Initialization ---
        // â–¼â–¼â–¼ è«‹åœ¨æ­¤è™•è²¼ä¸Šæ‚¨çš„ Firebase è¨­å®šç¢¼ â–¼â–¼â–¼
        const firebaseConfig = {
  apiKey: "AIzaSyCWYuU_AFVVgo4BamTeT0like9R2Mbj-3w",
  authDomain: "whiteboard2-f5e52.firebaseapp.com",
  projectId: "whiteboard2-f5e52",
  storageBucket: "whiteboard2-f5e52.firebasestorage.app",
  messagingSenderId: "652678145595",
  appId: "1:652678145595:web:c999442b1b745f35cdde1e"
        };
        // â–²â–²â–² è«‹åœ¨æ­¤è™•è²¼ä¸Šæ‚¨çš„ Firebase è¨­å®šç¢¼ â–²â–²â–²

        function initApp() {
            if (!firebaseConfig || !firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY") {
                setupModal.classList.remove('hidden');
                landingView.innerHTML = `<div class="p-8 bg-white rounded-lg shadow-xl text-center">
                    <h1 class="text-2xl font-bold text-red-600">è«‹å…ˆè¨­å®š Firebase</h1>
                    <p class="mt-2 text-gray-700">è«‹ä¾ç…§å½ˆå‡ºè¦–çª—çš„èªªæ˜ï¼Œåœ¨ç¨‹å¼ç¢¼ä¸­å®Œæˆè¨­å®šå¾Œï¼Œé‡æ–°æ•´ç†é é¢ã€‚</p>
                </div>`;
                return;
            }

            try {
                firebaseApp = initializeApp(firebaseConfig);
                db = getFirestore(firebaseApp);
                auth = getAuth(firebaseApp);

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        // User is signed in anonymously.
                        console.log("Anonymous user signed in:", user.uid);

                        // Check if there's an auto-switch state in sessionStorage
                        const autoSwitchData = sessionStorage.getItem('autoSwitchCanvas');
                        if (autoSwitchData) {
                            try {
                                const switchInfo = JSON.parse(autoSwitchData);
                                console.log('[AutoSwitch] Found auto-switch data:', switchInfo);

                                // Clear the flag immediately to prevent loops
                                sessionStorage.removeItem('autoSwitchCanvas');

                                // Auto-enter the whiteboard after a short delay to ensure Firebase is ready
                                setTimeout(() => {
                                    console.log('[AutoSwitch] Auto-entering whiteboard:', switchInfo.sessionId);
                                    enterWhiteboard(switchInfo.sessionId, switchInfo.role, switchInfo.name);
                                }, 500);
                            } catch (error) {
                                console.error('[AutoSwitch] Error parsing auto-switch data:', error);
                                sessionStorage.removeItem('autoSwitchCanvas');
                            }
                        }
                    } else {
                        // User is signed out.
                        signInAnonymously(auth).catch(error => {
                            console.error("Anonymous sign-in failed:", error);
                            showMessage("ç„¡æ³•é€£æ¥åˆ°å¾Œç«¯æœå‹™ï¼Œè«‹æª¢æŸ¥æ‚¨çš„Firebaseè¨­å®šï¼Œç‰¹åˆ¥æ˜¯ç¢ºèªæ˜¯å¦å·²å•Ÿç”¨ã€ŒåŒ¿åç™»å…¥ã€ã€‚");
                        });
                    }
                });

                landingView.classList.remove('hidden');

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessage("Firebase è¨­å®šæ ¼å¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¨­å®šã€‚");
            }
        }

        // --- Session Management ---
        const TEACHER_PASSWORD = "tpet"; // æ•™å¸«å¯†ç¢¼

        // New teacher login flow
        document.getElementById('teacher-password-submit-btn').addEventListener('click', async () => {
            const inputPassword = document.getElementById('teacher-password').value.trim();
            if (inputPassword !== TEACHER_PASSWORD) {
                showMessage("âŒ å¯†ç¢¼éŒ¯èª¤ï¼\nè«‹è¼¸å…¥æ­£ç¢ºçš„æ•™å¸«å¯†ç¢¼ã€‚");
                return;
            }

            const step1Btn = document.getElementById('teacher-password-submit-btn');
            step1Btn.disabled = true;
            step1Btn.textContent = 'è¼‰å…¥ä¸­...';

            try {
                const dropdown = document.getElementById('existing-sessions-dropdown');
                dropdown.innerHTML = '<option value="">æ­£åœ¨è¼‰å…¥ç™½æ¿åˆ—è¡¨...</option>';
                
                const sessionsQuery = query(collection(db, "sessions"));
                const sessionsSnapshot = await getDocs(sessionsQuery);
                
                dropdown.innerHTML = '<option value="">-- è«‹é¸æ“‡æˆ–æ–¼ä¸‹æ–¹è¼¸å…¥æ–°ID --</option>';

                if (sessionsSnapshot.empty) {
                    const option = document.createElement('option');
                    option.textContent = 'ç›®å‰æ²’æœ‰ç¾å­˜ç™½æ¿';
                    option.disabled = true;
                    dropdown.appendChild(option);
                } else {
                    sessionsSnapshot.forEach(doc => {
                        const option = document.createElement('option');
                        option.value = doc.id;
                        option.textContent = doc.id;
                        dropdown.appendChild(option);
                    });
                }
                
                document.getElementById('teacher-login-step1').classList.add('hidden');
                document.getElementById('teacher-login-step2').classList.remove('hidden');

            } catch (error) {
                console.error("Error fetching existing sessions:", error);
                showMessage("è®€å–ç¾æœ‰ç™½æ¿åˆ—è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚");
                step1Btn.disabled = false;
                step1Btn.textContent = 'ä¸‹ä¸€æ­¥';
            }
        });

        document.getElementById('enter-whiteboard-btn').addEventListener('click', async () => {
            const dropdownId = document.getElementById('existing-sessions-dropdown').value;
            const inputId = document.getElementById('session-id-teacher').value.trim();
            
            let sessionIdToUse = inputId || dropdownId;

            if (!sessionIdToUse) {
                sessionIdToUse = Math.random().toString(36).substring(2, 7).toUpperCase();
            }

            if (!auth.currentUser) {
                showMessage("ç„¡æ³•é©—è­‰ä½¿ç”¨è€…èº«ä»½ï¼Œè«‹é‡æ–°æ•´ç†é é¢å¾Œå†è©¦ä¸€æ¬¡ã€‚");
                return;
            }

            const sessionRef = doc(db, "sessions", sessionIdToUse);
            const sessionSnap = await getDoc(sessionRef);

            if (sessionSnap.exists()) {
                const takeOver = await showConfirm(
                    'ç™½æ¿å·²å­˜åœ¨',
                    `ç™½æ¿ID "${sessionIdToUse}" å·²è¢«ä½¿ç”¨ã€‚æ‚¨æ˜¯å¦è¦å–ä»£ç›®å‰çš„è€å¸«ä¸¦æ¥ç®¡é€™å€‹ç™½æ¿ï¼Ÿ`
                );
                if (takeOver) {
                    await updateDoc(sessionRef, { "metadata.ownerUid": auth.currentUser.uid });
                    enterWhiteboard(sessionIdToUse, "teacher", "è€å¸«");
                }
            } else {
                await setDoc(sessionRef, {
                    metadata: {
                        createdAt: serverTimestamp(),
                        isLocked: false,
                        ownerUid: auth.currentUser.uid,
                        showAuthorNames: false,
                        allowStudentEditAll: false,
                        pageCount: 1
                    }
                });
                enterWhiteboard(sessionIdToUse, "teacher", "è€å¸«");
            }
        });

        // Logic for deleting a selected session from the landing page
        async function deleteSingleSession(idToDelete) {
            console.log(`[åˆªé™¤å–®ä¸€ç™½æ¿] é–‹å§‹åˆªé™¤ç™½æ¿ ID: ${idToDelete}`);
            showLoading(true, `æ­£åœ¨åˆªé™¤ç™½æ¿ ${idToDelete}...`);

            try {
                const deletePromises = [];

                // Delete all participants in the session
                const participantsRef = collection(db, "sessions", idToDelete, "participants");
                const participantsSnap = await getDocs(participantsRef);
                participantsSnap.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });

                // Delete all canvasObjects in the session
                const objectsRef = collection(db, "sessions", idToDelete, "canvasObjects");
                const objectsSnap = await getDocs(objectsRef);
                objectsSnap.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });

                await Promise.all(deletePromises);
                console.log(`[åˆªé™¤å–®ä¸€ç™½æ¿] ç™½æ¿ ${idToDelete} çš„å­é›†åˆéƒ½å·²åˆªé™¤`);

                // Delete the main session document
                const sessionRef = doc(db, "sessions", idToDelete);
                await deleteDoc(sessionRef);
                console.log(`[åˆªé™¤å–®ä¸€ç™½æ¿] ç™½æ¿ ${idToDelete} å·²å®Œå…¨åˆªé™¤`);

                showLoading(false);
                showMessage(`ç™½æ¿ "${idToDelete}" å·²æˆåŠŸåˆªé™¤ã€‚`);

            } catch (error) {
                console.error(`[åˆªé™¤å–®ä¸€ç™½æ¿] åˆªé™¤éç¨‹ç™¼ç”ŸéŒ¯èª¤ (ID: ${idToDelete}):`, error);
                showLoading(false);
                showMessage(`åˆªé™¤ç™½æ¿æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}`);
            }
        }

        document.getElementById('existing-sessions-dropdown').addEventListener('input', (e) => {
            const deleteBtn = document.getElementById('delete-selected-session-btn');
            if (e.target.value) {
                deleteBtn.classList.remove('hidden');
            } else {
                deleteBtn.classList.add('hidden');
            }
        });

        document.getElementById('delete-selected-session-btn').addEventListener('click', async () => {
            const dropdown = document.getElementById('existing-sessions-dropdown');
            const sessionIdToDelete = dropdown.value;

            if (!sessionIdToDelete) {
                showMessage("è«‹å…ˆå¾ä¸‹æ‹‰é¸å–®ä¸­é¸æ“‡ä¸€å€‹è¦åˆªé™¤çš„ç™½æ¿ã€‚");
                return;
            }

            const confirmed = await showConfirm(
                'âš ï¸ ç¢ºèªåˆªé™¤ç™½æ¿',
                `æ­¤å‹•ä½œå°‡æ°¸ä¹…åˆªé™¤ç™½æ¿ "${sessionIdToDelete}" çš„æ‰€æœ‰è³‡æ–™ï¼Œä¸”ç„¡æ³•å¾©åŸã€‚æ‚¨ç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ`
            );

            if (confirmed) {
                await deleteSingleSession(sessionIdToDelete);
                // Refresh the dropdown
                const optionToRemove = dropdown.querySelector(`option[value="${sessionIdToDelete}"]`);
                if(optionToRemove) {
                    optionToRemove.remove();
                }
                dropdown.value = ""; // Reset selection
                document.getElementById('delete-selected-session-btn').classList.add('hidden');
            }
        });

        document.getElementById('join-session-btn').addEventListener('click', async () => {
            const studentName = document.getElementById('student-name').value.trim();
            if (!studentName) {
                showMessage("âŒ è«‹è¼¸å…¥æ‚¨çš„å§“åã€‚");
                return;
            }

            let joinSessionId = document.getElementById('session-id-student').value.trim();
            if (!joinSessionId) {
                showMessage("âŒ è«‹è¼¸å…¥ç™½æ¿IDã€‚");
                return;
            }
            const sessionRef = doc(db, "sessions", joinSessionId);
            const sessionSnap = await getDoc(sessionRef);

            if (!sessionSnap.exists()) {
                showMessage(`âŒ ç™½æ¿ID "${joinSessionId}" ä¸å­˜åœ¨ï¼Œè«‹ç¢ºèªå¾Œå†è¼¸å…¥ã€‚`);
                return;
            }
            enterWhiteboard(joinSessionId, "student", studentName);
        });

        // Enter key support for teacher section
        document.getElementById('teacher-password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('teacher-password-submit-btn').click();
            }
        });
        document.getElementById('session-id-teacher').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('enter-whiteboard-btn').click();
            }
        });

        // Enter key support for student section
        document.getElementById('student-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('join-session-btn').click();
            }
        });
        document.getElementById('session-id-student').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('join-session-btn').click();
            }
        });

        document.getElementById('show-setup-btn').addEventListener('click', () => {
            setupModal.classList.remove('hidden');
        });

        document.getElementById('close-setup-btn').addEventListener('click', () => {
            setupModal.classList.add('hidden');
        });

        // Event listener for clicking on session ID to switch canvas
        document.getElementById('session-info').addEventListener('click', () => {
            showCanvasSwitchModal();
        });

        // Event listener for closing the switch canvas modal
        document.getElementById('close-switch-canvas-modal').addEventListener('click', () => {
            document.getElementById('switch-canvas-modal').classList.add('hidden');
        });

        async function enterWhiteboard(id, role, name) {
            sessionId = id;
            userRole = role;
            
            await setupParticipant(id, role, name);

            // NEW: Listen for current user's participant document deletion
            const currentUserParticipantRef = doc(db, "sessions", sessionId, "participants", auth.currentUser.uid);
            const unsubscribeCurrentUserParticipant = onSnapshot(currentUserParticipantRef, (docSnap) => {
                if (!docSnap.exists()) {
                    // Current user's participant document was deleted (kicked)
                    unsubscribes.forEach(unsub => unsub()); // Clean up all listeners
                    unsubscribes.length = 0;
                    window.location.reload();
                }
            });
            unsubscribes.push(unsubscribeCurrentUserParticipant);

            landingView.classList.add('hidden');
            whiteboardView.classList.remove('hidden');
            document.getElementById('session-id-display').textContent = sessionId;

            if (userRole === 'teacher') {
                document.getElementById('teacher-tools').classList.remove('hidden');
            } else if (userRole === 'student') {
                const studentNameContainer = document.getElementById('student-name-display-container');
                const studentNameEl = document.getElementById('student-name-display');
                studentNameEl.textContent = name;
                studentNameContainer.classList.remove('hidden');
            }
            
            initWhiteboard();
            listenToSessionChanges();
        }

        // Fetch all available (non-deleted) canvases
        async function fetchAvailableCanvases() {
            try {
                const sessionsQuery = query(collection(db, "sessions"));
                const sessionsSnapshot = await getDocs(sessionsQuery);

                const canvases = [];
                sessionsSnapshot.forEach(doc => {
                    const data = doc.data();
                    // Only include canvases that are not marked as deleted
                    // If there's no metadata.deleted field, we consider it as not deleted
                    const isDeleted = data.metadata && data.metadata.deleted === true;
                    if (!isDeleted) {
                        canvases.push({
                            id: doc.id,
                            data: data
                        });
                    }
                });

                return canvases;
            } catch (error) {
                console.error("Error fetching available canvases:", error);
                showMessage("è¼‰å…¥ç™½æ¿åˆ—è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤");
                return [];
            }
        }

        // Switch to a different canvas
        async function switchToCanvas(newSessionId) {
            if (newSessionId === sessionId) {
                showMessage("æ‚¨å·²ç¶“åœ¨é€™å€‹ç™½æ¿ä¸­äº†");
                return;
            }

            try {
                // Check if the target session exists and if it has an owner
                const sessionRef = doc(db, "sessions", newSessionId);
                const sessionSnap = await getDoc(sessionRef);

                if (sessionSnap.exists()) {
                    const sessionData = sessionSnap.data();
                    const currentOwnerUid = sessionData.metadata?.ownerUid;

                    // If the session has an owner and it's not the current user, ask for confirmation
                    if (currentOwnerUid && currentOwnerUid !== auth.currentUser.uid) {
                        const takeOver = await showConfirm(
                            'ç™½æ¿å·²å­˜åœ¨',
                            `ç™½æ¿ID "${newSessionId}" å·²è¢«ä½¿ç”¨ã€‚æ‚¨æ˜¯å¦è¦å–ä»£ç›®å‰çš„è€å¸«ä¸¦æ¥ç®¡é€™å€‹ç™½æ¿ï¼Ÿ`
                        );

                        if (!takeOver) {
                            // User cancelled, don't switch
                            return;
                        }

                        // User confirmed, update the owner
                        await updateDoc(sessionRef, { "metadata.ownerUid": auth.currentUser.uid });
                    }
                }

                // Save switch state to sessionStorage for auto-login after reload
                sessionStorage.setItem('autoSwitchCanvas', JSON.stringify({
                    sessionId: newSessionId,
                    role: userRole,
                    name: userRole === 'teacher' ? 'è€å¸«' : 'å­¸ç”Ÿ'
                }));

                console.log(`[switchToCanvas] Saved state and reloading page to switch to: ${newSessionId}`);

                // Reload the page - this ensures complete re-initialization
                window.location.reload();
            } catch (error) {
                console.error("Error switching canvas:", error);
                showMessage("åˆ‡æ›ç™½æ¿æ™‚ç™¼ç”ŸéŒ¯èª¤");
            }
        }

        // Show canvas switch modal
        async function showCanvasSwitchModal() {
            // Only allow teachers to switch canvases
            if (userRole !== 'teacher') {
                showMessage("åªæœ‰æ•™å¸«å¯ä»¥åˆ‡æ›ç™½æ¿");
                return;
            }

            const modal = document.getElementById('switch-canvas-modal');
            const container = document.getElementById('canvas-list-container');

            // Show loading message
            container.innerHTML = '<div class="text-center text-gray-500">è¼‰å…¥ä¸­...</div>';
            modal.classList.remove('hidden');

            // Fetch available canvases
            const canvases = await fetchAvailableCanvases();

            // Render canvas list
            if (canvases.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-500">ç›®å‰æ²’æœ‰å¯ç”¨çš„ç™½æ¿</div>';
            } else {
                container.innerHTML = '';
                canvases.forEach(canvasData => {
                    const canvasItem = document.createElement('div');
                    const isCurrentCanvas = canvasData.id === sessionId;

                    canvasItem.className = `p-3 rounded-lg border-2 transition-all ${
                        isCurrentCanvas
                            ? 'border-blue-500 bg-blue-50'
                            : 'border-gray-200 hover:border-blue-300 hover:bg-gray-50 cursor-pointer'
                    }`;

                    canvasItem.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="font-bold text-gray-800">${canvasData.id}</div>
                                ${isCurrentCanvas ? '<div class="text-xs text-blue-600 mt-1">ç›®å‰ç™½æ¿</div>' : ''}
                            </div>
                            ${!isCurrentCanvas ? '<div class="text-blue-600 text-sm">é»æ“Šåˆ‡æ›</div>' : ''}
                        </div>
                    `;

                    if (!isCurrentCanvas) {
                        canvasItem.addEventListener('click', async () => {
                            modal.classList.add('hidden');
                            await switchToCanvas(canvasData.id);
                        });
                    }

                    container.appendChild(canvasItem);
                });
            }
        }

        async function setupParticipant(sessionId, userRole, userName) {
            if (!auth.currentUser) {
                console.error("User not authenticated, cannot set up participant.");
                return;
            }
            const participantRef = doc(db, "sessions", sessionId, "participants", auth.currentUser.uid);
            await setDoc(participantRef, {
                name: userName,
                role: userRole,
                joinedAt: serverTimestamp(),
                isLockedByTeacher: false // Add this
            });

            window.addEventListener('beforeunload', () => {
                // This is best-effort, might not run on all browsers/situations
                deleteDoc(participantRef);
            });
        }
        
        // --- Page Management --- 
        function renderPagesUI(pageCount, activePage) {
            const pagesToolbar = document.getElementById('pages-toolbar');
            pagesToolbar.innerHTML = ''; // Clear existing

            for (let i = 1; i <= pageCount; i++) {
                const pageBtnContainer = document.createElement('div'); // Use a container
                pageBtnContainer.className = 'relative';

                const pageBtn = document.createElement('button');
                pageBtn.className = `w-16 h-10 rounded-md flex items-center justify-center text-lg font-bold border-2`;
                pageBtn.textContent = i;
                if (i === activePage) {
                    pageBtn.classList.add('bg-blue-500', 'border-blue-300');
                } else {
                    pageBtn.classList.add('bg-gray-700', 'border-gray-600', 'hover:bg-gray-600');
                }
                pageBtn.addEventListener('click', () => switchPage(i));
                
                pageBtnContainer.appendChild(pageBtn);

                if (userRole === 'teacher') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'absolute -top-2 -right-2 w-6 h-6 bg-red-600 text-white rounded-full flex items-center justify-center text-sm font-bold border-2 border-white hover:bg-red-700 z-10';
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.title = `åˆªé™¤ç¬¬ ${i} é `;
                    deleteBtn.dataset.page = i;
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent page switch
                        const pageToDelete = parseInt(e.currentTarget.dataset.page, 10);
                        deletePage(pageToDelete);
                    });
                    pageBtnContainer.appendChild(deleteBtn);
                }
                
                pagesToolbar.appendChild(pageBtnContainer);
            }

            if (userRole === 'teacher') {
                const addPageBtn = document.createElement('button');
                addPageBtn.className = 'w-16 h-10 rounded-md flex items-center justify-center text-2xl font-bold bg-green-600 hover:bg-green-700 border-2 border-green-500 mt-2';
                addPageBtn.textContent = '+';
                addPageBtn.title = 'æ–°å¢ç•«å¸ƒ';
                addPageBtn.addEventListener('click', addPage);
                pagesToolbar.appendChild(addPageBtn);
            }
        }

        async function addPage() {
            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const newPageCount = (sfDoc.data().metadata.pageCount || 1) + 1;
                    transaction.update(sessionRef, { "metadata.pageCount": newPageCount });
                });
            } catch (e) {
                console.error("Add page transaction failed: ", e);
            }
        }

        function switchPage(pageNum) {
            if (pageNum === currentPage) return;
            resetInactivityTimer(); // Reset timer on user activity

            // Save current page's view state before switching
            if (canvas) {
                pageViewStates.set(currentPage, {
                    zoom: canvas.getZoom(),
                    viewportTransform: canvas.viewportTransform.slice() // Clone the array
                });
                console.log(`[switchPage] Saved view state for page ${currentPage}:`, {
                    zoom: canvas.getZoom(),
                    vpt: canvas.viewportTransform
                });
            }

            currentPage = pageNum;
            console.log(`Switched to page ${currentPage}`);
            listenToPageObjects(pageNum);

            // Restore view state for the new page (if it exists)
            if (canvas && pageViewStates.has(pageNum)) {
                const savedState = pageViewStates.get(pageNum);
                canvas.setZoom(savedState.zoom);
                canvas.setViewportTransform(savedState.viewportTransform);
                canvas.requestRenderAll();

                // Update zoom UI
                const zoomSlider = document.getElementById('zoom-slider');
                const zoomLabel = document.getElementById('zoom-label');
                if (zoomSlider) zoomSlider.value = savedState.zoom;
                if (zoomLabel) zoomLabel.textContent = `${Math.round(savedState.zoom * 100)}%`;

                console.log(`[switchPage] Restored view state for page ${pageNum}:`, savedState);
            } else {
                console.log(`[switchPage] No saved view state for page ${pageNum}, using default`);
            }

            // Update UI highlighting without re-fetching page count
            const pagesToolbar = document.getElementById('pages-toolbar');
            const buttons = pagesToolbar.querySelectorAll('button');
            buttons.forEach(btn => {
                const isPageNumBtn = !btn.textContent.includes('+');
                if (!isPageNumBtn) return;

                btn.classList.remove('bg-blue-500', 'border-blue-300', 'bg-gray-700', 'border-gray-600', 'hover:bg-gray-600');
                if (parseInt(btn.textContent) === pageNum) {
                    btn.classList.add('bg-blue-500', 'border-blue-300');
                } else {
                    btn.classList.add('bg-gray-700', 'border-gray-600', 'hover:bg-gray-600');
                }
            });
        }

        // --- Firestore Real-time Sync --- 
        function listenToPageObjects(pageNum) {
            // Unsubscribe from the old page's listener if it exists
            if (unsubscribePageObjects) {
                unsubscribePageObjects();
            }

            // Save view state before clearing (canvas.clear() resets viewport)
            const savedZoom = canvas.getZoom();
            const savedVPT = canvas.viewportTransform.slice();

            // Clear canvas and local object map for the new page
            canvas.clear();
            fabricObjects.clear();

            // Restore view state after clearing
            canvas.setZoom(savedZoom);
            canvas.setViewportTransform(savedVPT);
            canvas.requestRenderAll();

            const objectsRef = collection(db, "sessions", sessionId, "canvasObjects");
            const q = query(objectsRef, where("page", "==", pageNum));

            unsubscribePageObjects = onSnapshot(q, (snapshot) => {
                const changes = snapshot.docChanges();
                console.log(`[Firestore] Received ${changes.length} changes`);

                changes.forEach((change) => {
                    const docId = change.doc.id;
                    const objectData = change.doc.data();

                    if (change.type === "added") {
                        if (!fabricObjects.has(docId)) {
                            console.log(`ğŸ“¥ [Firestore] Receiving new object from other user (docId: ${docId})`, {
                                type: objectData.type,
                                authorUid: objectData.authorUid,
                                page: objectData.page,
                                currentUserPage: currentPage
                            });

                            const dataToEnliven = objectData.data;

                            // Handle path deserialization for paths
                            if (dataToEnliven.type === 'path') {
                                if (typeof dataToEnliven.path === 'string') {
                                    console.log(`[Firestore] ğŸ“ Parsing path JSON string for drawing sync`);
                                    try {
                                        dataToEnliven.path = JSON.parse(dataToEnliven.path);
                                        console.log(`[Firestore] âœ… Path parsed successfully, ${dataToEnliven.path.length} commands`);
                                    } catch (err) {
                                        console.error(`[Firestore] âŒ Failed to parse path:`, err);
                                    }
                                } else if (Array.isArray(dataToEnliven.path)) {
                                    console.log(`[Firestore] â„¹ï¸ Path already an array (${dataToEnliven.path.length} commands)`);
                                } else {
                                    console.error(`[Firestore] âŒ Path data missing or invalid type:`, typeof dataToEnliven.path);
                                }

                                // IMPORTANT: Ensure fill is null for stroke-only paths
                                // This prevents the black triangle appearance
                                if (!dataToEnliven.fill) {
                                    dataToEnliven.fill = null;
                                }

                                // Log path details for debugging
                                console.log('[Firestore] ğŸ“ Received path details:', {
                                    stroke: dataToEnliven.stroke,
                                    strokeWidth: dataToEnliven.strokeWidth,
                                    fill: dataToEnliven.fill,
                                    hasPath: !!dataToEnliven.path
                                });
                            }

                            remoteUpdateGuard = true;
                            fabric.util.enlivenObjects([dataToEnliven], function (objects) {
                                const fabricObj = objects[0];
                                if (!fabricObj) {
                                    console.error('[Firestore] âŒ Failed to enliven object');
                                    remoteUpdateGuard = false;
                                    return;
                                }
                                fabricObj.docId = docId;
                                fabricObj.authorUid = objectData.authorUid;
                                fabricObj.authorName = objectData.authorName; // Preserve author name from imported JSON
                                fabricObj.page = objectData.page;
                                setupNewObject(fabricObj);
                                fabricObjects.set(docId, fabricObj);
                                if (showAuthorNames && fabricObj.authorUid) {
                                    addAuthorNameText(fabricObj);
                                }
                                remoteUpdateGuard = false;
                                canvas.requestRenderAll();
                                console.log(`âœ… [Firestore] Successfully added and rendered iPad drawing on this canvas`, {
                                    docId: docId,
                                    type: fabricObj.type
                                });
                            });
                        } else {
                            console.log(`[Firestore] â­ï¸ Object ${docId} already exists locally, skipping`);
                        }
                    }
                    if (change.type === "modified") {
                        const existingObj = fabricObjects.get(docId);
                        if (existingObj) {
                            const dataToSet = objectData.data;

                            // Handle path deserialization for paths
                            if (dataToSet.type === 'path') {
                                if (typeof dataToSet.path === 'string') {
                                    try {
                                        dataToSet.path = JSON.parse(dataToSet.path);
                                        console.log(`[Firestore] ğŸ“ Path updated: ${dataToSet.path.length} commands`);
                                    } catch (err) {
                                        console.error(`[Firestore] âŒ Failed to parse updated path:`, err);
                                    }
                                } else if (!Array.isArray(dataToSet.path)) {
                                    console.error(`[Firestore] âŒ Updated path data invalid:`, typeof dataToSet.path);
                                }

                                // IMPORTANT: Ensure fill is null for stroke-only paths
                                if (!dataToSet.fill) {
                                    dataToSet.fill = null;
                                }
                            }

                            console.log(`[Firestore] âœ… Updating object ${docId}:`, {
                                type: dataToSet.type,
                                position: `(${dataToSet.left?.toFixed(0)}, ${dataToSet.top?.toFixed(0)})`,
                                scale: `(${dataToSet.scaleX?.toFixed(2)}, ${dataToSet.scaleY?.toFixed(2)})`,
                                angle: dataToSet.angle?.toFixed(0)
                            });

                            // Temporarily enable remote update guard to prevent echo
                            remoteUpdateGuard = true;

                            // Update object properties
                            existingObj.set(dataToSet);
                            existingObj.setCoords();
                            existingObj.authorUid = objectData.authorUid;

                            // Re-apply permissions
                            applyObjectPermissions(existingObj);

                            // Update author name text if visible
                            if (showAuthorNames && existingObj.authorUid) {
                                removeAuthorNameText(existingObj);
                                addAuthorNameText(existingObj);
                            }

                            // Mark as dirty to ensure it re-renders
                            existingObj.dirty = true;

                            // Re-enable updates
                            remoteUpdateGuard = false;

                            // Force immediate render for this change
                            canvas.requestRenderAll();
                        } else {
                            console.warn(`[Firestore] Object ${docId} not found in local map`);
                        }
                    }
                    if (change.type === "removed") {
                        const objToRemove = fabricObjects.get(docId);
                        if (objToRemove) {
                            console.log(`[Firestore] Removing object: ${docId}`);
                            remoteUpdateGuard = true;
                            removeAuthorNameText(objToRemove);
                            canvas.remove(objToRemove);
                            fabricObjects.delete(docId);
                            remoteUpdateGuard = false;
                            canvas.requestRenderAll();
                        }
                    }
                });

                // Final refresh to ensure all changes are visible
                setTimeout(() => {
                    if (canvas) {
                        canvas.forEachObject(obj => {
                            obj.setCoords();
                        });
                        canvas.requestRenderAll();
                        console.log('[Firestore] Final refresh complete');
                    }
                }, 100);
            });
            unsubscribes.push(unsubscribePageObjects);
        }

        function listenToSessionChanges() {
            // Listener for metadata (e.g., lock state, page count)
            const metadataRef = doc(db, "sessions", sessionId);
            const unsubscribeMetadata = onSnapshot(metadataRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data().metadata;
                    if (data.isLocked !== isLocked) {
                        handleLockState(data.isLocked);
                    }
                    // If another teacher takes over, this client is forced to leave.
                    if (userRole === 'teacher' && data.ownerUid && data.ownerUid !== auth.currentUser.uid) {
                                                            unsubscribes.forEach(unsub => unsub());
                                                            unsubscribes.length = 0;
                                                            window.location.reload();                        return;
                    }
            
                    // Handle showAuthorNames state change
                    if (data.showAuthorNames !== showAuthorNames) {
                        showAuthorNames = data.showAuthorNames;

                        // Update button appearance
                        const authorBtn = document.getElementById('toggle-author-names-btn');
                        if (showAuthorNames) {
                            authorBtn.classList.add('active');
                        } else {
                            authorBtn.classList.remove('active');
                        }

                        canvas.forEachObject(obj => {
                            if (obj.authorUid) {
                                if (showAuthorNames) {
                                    addAuthorNameText(obj);
                                } else {
                                    removeAuthorNameText(obj);
                                }
                            }
                        });
                        canvas.requestRenderAll();
                    }

                    // Handle allowStudentEditAll state change
                    if (data.allowStudentEditAll !== allowStudentEditAll) {
                        allowStudentEditAll = data.allowStudentEditAll || false;

                        // Update button appearance
                        const allowEditAllIcon = document.getElementById('allow-edit-all-icon');
                        if (allowEditAllIcon) {
                            if (allowStudentEditAll) {
                                allowEditAllIcon.classList.add('text-green-500');
                            } else {
                                allowEditAllIcon.classList.remove('text-green-500');
                            }
                        }

                        // Re-apply permissions to all objects
                        canvas.forEachObject(obj => {
                            applyObjectPermissions(obj);
                        });
                        canvas.requestRenderAll();
                    }

                    // Handle page count change
                    const pageCount = data.pageCount || 1;
                    renderPagesUI(pageCount, currentPage);

                } else {
                                                    // Session was deleted by the teacher
                                                    window.location.reload();                }
            });
            unsubscribes.push(unsubscribeMetadata);

            // Listener for participants
            const participantsRef = collection(db, "sessions", sessionId, "participants");
            const unsubscribeParticipants = onSnapshot(participantsRef, (snapshot) => {
                let studentCount = 0;
                participantDataMap.clear();
                snapshot.forEach(doc => {
                    const participant = { uid: doc.id, ...doc.data() };
                    participantDataMap.set(doc.id, participant);
                    if (participant.role === 'student') {
                        studentCount++;
                    }
                });
                document.getElementById('participant-display').textContent = `å­¸ç”Ÿäººæ•¸: ${studentCount}`;

                // Check if current user's individual lock state has changed
                const currentParticipantData = participantDataMap.get(auth.currentUser.uid);
                if (userRole === 'student' && currentParticipantData) {
                    const newIndividualLockState = currentParticipantData.isLockedByTeacher;
                    if (newIndividualLockState !== isCurrentUserIndividuallyLocked) {
                        isCurrentUserIndividuallyLocked = newIndividualLockState; // Update tracker
                        // Re-evaluate UI based on current global lock state (which will now consider individual lock)
                        handleLockState(isLocked); // Pass the current global lock state
                    }
                }

                // If showing names, refresh them
                if (showAuthorNames) {
                    canvas.forEachObject(obj => {
                        if (obj.authorUid) {
                            removeAuthorNameText(obj); // Remove old text
                            addAuthorNameText(obj);    // Add new text
                        }
                    });
                    canvas.requestRenderAll();
                }
                // Re-render participant list if modal is open
                if (!document.getElementById('participant-list-modal').classList.contains('hidden')) {
                    renderParticipantList();
                }
            });
            unsubscribes.push(unsubscribeParticipants);

            // Initial listener for page 1 objects
            listenToPageObjects(1);
        }

        // --- Whiteboard Initialization ---
        let canvas, activeTool = 'select';

        function initWhiteboard() {
            canvas = new fabric.Canvas('whiteboard-canvas', {
                width: window.innerWidth,
                height: window.innerHeight,
                fireRightClick: true,
                stopContextMenu: true,
                backgroundColor: '#f8fafc', // gray-50
                enableRetinaScaling: true,
                allowTouchScrolling: true, // Changed to true to support iPad drawing
                selection: true, // Enable multi-select box for select mode (default)
                isDrawingMode: false
            });

            // Initialize free drawing brush for iPad/touch devices
            canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
            canvas.freeDrawingBrush.color = '#000000';
            canvas.freeDrawingBrush.width = 2;

            console.log('[initWhiteboard] Canvas initialized', {
                width: canvas.width,
                height: canvas.height,
                isDrawingMode: canvas.isDrawingMode
            });

            window.addEventListener('resize', resizeCanvas);

            // Paste image from clipboard
            window.addEventListener('paste', (e) => {
                if (e.clipboardData) {
                    const items = e.clipboardData.items;
                    if (items) {
                        for (let i = 0; i < items.length; i++) {
                            if (items[i].type.indexOf('image') !== -1) {
                                const blob = items[i].getAsFile();
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    addImageToCanvas(event.target.result);
                                };
                                reader.readAsDataURL(blob);
                            }
                        }
                    }
                }
            });

            // --- Zoom Control Logic ---
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomLabel = document.getElementById('zoom-label');
            const updateZoomUI = () => {
                if (!canvas) return;
                const zoom = canvas.getZoom();
                if (zoomSlider) zoomSlider.value = zoom;
                if (zoomLabel) zoomLabel.textContent = `${Math.round(zoom * 100)}%`;
            };
            
            // Pan and Zoom
            canvas.on('mouse:wheel', function(opt) {
                resetInactivityTimer(); // Reset timer on user activity
                const delta = opt.e.deltaY;
                let zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 20) zoom = 20;
                if (zoom < 0.01) zoom = 0.01;
                canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
                updateZoomUI(); // Update slider and label
            });

            canvas.on('mouse:down', function(opt) {
                const evt = opt.e;
                resetInactivityTimer(); // Reset timer on user activity

                // Track touch events for improved two-finger detection
                if (evt.touches) {
                    const currentTime = Date.now();
                    const touchCount = evt.touches.length;

                    // Reset tracking if it's been too long since last touch (>300ms)
                    if (currentTime - touchStartTime > 300) {
                        initialTouchCount = 0;
                        touchStartTime = 0;
                    }

                    // Check for two-finger touch gesture
                    if (touchCount === 2) {
                        isPanning = true;
                        this.lastDist = Math.hypot(evt.touches[0].clientX - evt.touches[1].clientX, evt.touches[0].clientY - evt.touches[1].clientY);
                        lastPointer = {
                            x: (evt.touches[0].clientX + evt.touches[1].clientX) / 2,
                            y: (evt.touches[0].clientY + evt.touches[1].clientY) / 2
                        };
                        canvas.selection = false;
                        evt.preventDefault();
                        console.log('[Touch] é›™æŒ‡ç¸®æ”¾æ¨¡å¼å·²å•Ÿå‹•');
                        return;
                    }

                    // Track first touch timing
                    if (touchCount === 1 && initialTouchCount === 0) {
                        initialTouchCount = 1;
                        touchStartTime = currentTime;
                    }
                }

                // IMPORTANT: If in drawing mode (pen tool), let Fabric.js handle it natively
                // Don't interfere with Fabric's internal touch/mouse handlers for drawing
                if (canvas.isDrawingMode) {
                    console.log('[mouse:down] Drawing mode active, letting Fabric handle it');
                    return;
                }

                // Pan mode: if pan tool is active OR Alt key/Right-click (but not for touch)
                if (activeTool === 'pan' && evt.touches && evt.touches.length === 1) {
                    // Pan mode with single touch
                    isPanning = true;
                    lastPointer = { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
                    canvas.selection = false;
                    this.setCursor('grabbing');
                    return;
                } else if (activeTool === 'pan' && !evt.touches) {
                    // Pan mode with mouse
                    isPanning = true;
                    lastPointer = { x: evt.clientX, y: evt.clientY };
                    canvas.selection = false;
                    this.setCursor('grabbing');
                    return;
                } else if (!evt.touches && (evt.altKey === true || opt.button === 2)) {
                    // Alt key or Right-click pan (mouse only)
                    isPanning = true;
                    lastPointer = { x: evt.clientX, y: evt.clientY };
                    canvas.selection = false;
                    this.setCursor('grabbing');
                    return;
                }

                // For shape drawing tools (rect, circle) - not select/pan mode and not pen mode
                if (activeTool !== 'select' && activeTool !== 'pan' && !canvas.isDrawingMode) {
                    startDrawing(opt);
                }
                // Note: When activeTool is 'select' and the user clicks/taps,
                // Fabric.js will automatically handle object selection and marquee selection
            });

            canvas.on('mouse:move', function(opt) {
                const e = opt.e;
                resetInactivityTimer(); // Reset timer on user activity

                // Detect if second finger joins during move (improved iPad support)
                if (e.touches && e.touches.length === 2 && !isPanning && initialTouchCount === 1) {
                    const currentTime = Date.now();
                    // If within 300ms of first touch, activate pinch zoom
                    if (touchStartTime > 0 && currentTime - touchStartTime < 300) {
                        isPanning = true;
                        this.lastDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                        lastPointer = {
                            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                        };
                        canvas.selection = false;
                        canvas.discardActiveObject();
                        canvas.requestRenderAll();
                        console.log('[Touch] é›™æŒ‡ç¸®æ”¾æ¨¡å¼å·²å•Ÿå‹• (ç§»å‹•æ™‚åµæ¸¬)');
                        return;
                    }
                }

                // Handle panning gestures
                if (isPanning) {
                    if (e.touches && e.touches.length === 2) { // Touch gesture move
                        const newDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                        const newPointer = {
                            x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                            y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                        };

                        // Zoom
                        let zoom = canvas.getZoom();
                        zoom *= newDist / this.lastDist;
                        if (zoom > 20) zoom = 20;
                        if (zoom < 0.01) zoom = 0.01;
                        canvas.zoomToPoint({ x: newPointer.x, y: newPointer.y }, zoom);
                        updateZoomUI(); // Update slider and label

                        // Pan
                        const vpt = canvas.viewportTransform;
                        vpt[4] += newPointer.x - lastPointer.x;
                        vpt[5] += newPointer.y - lastPointer.y;
                        canvas.requestRenderAll();

                        this.lastDist = newDist;
                        lastPointer = newPointer;
                    } else if (e.touches && e.touches.length === 1) { // Single touch pan move
                        const vpt = canvas.viewportTransform;
                        vpt[4] += e.touches[0].clientX - lastPointer.x;
                        vpt[5] += e.touches[0].clientY - lastPointer.y;
                        canvas.requestRenderAll();
                        lastPointer = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    } else if (!e.touches) { // Mouse pan move
                        const vpt = canvas.viewportTransform;
                        vpt[4] += e.clientX - lastPointer.x;
                        vpt[5] += e.clientY - lastPointer.y;
                        canvas.requestRenderAll();
                        lastPointer = { x: e.clientX, y: e.clientY };
                    }
                    return;
                }

                // If in drawing mode (pen tool), let Fabric.js handle it
                if (canvas.isDrawingMode) {
                    return;
                }

                // Handle shape drawing (rect, circle, arrow)
                continueDrawing(opt);
            });

            canvas.on('mouse:up', function(opt) {
                const wasPanning = isPanning;

                // Reset touch tracking based on remaining touches
                const evt = opt.e;
                if (!evt.touches || evt.touches.length === 0) {
                    // All fingers lifted - reset everything
                    isPanning = false;
                    touchStartTime = 0;
                    initialTouchCount = 0;
                } else if (evt.touches.length === 1) {
                    // One finger remains - reset for potential new gesture
                    isPanning = false;
                    touchStartTime = Date.now();
                    initialTouchCount = 1;
                } else {
                    // Still 2+ fingers - keep panning
                    isPanning = true;
                }

                // If in drawing mode (pen tool), let Fabric.js handle it
                // The path:created event will fire automatically when drawing is complete
                if (canvas.isDrawingMode) {
                    return;
                }

                // Finalize shape drawing (rect, circle, arrow)
                stopDrawing();

                // For shape drawing tools, ensure the canvas returns to a non-selecting state
                if (['rect', 'circle', 'arrow'].includes(activeTool)) {
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                }

                // Only enable group selection if the tool is 'select'
                canvas.selection = (activeTool === 'select');
                console.log(`[mouse:up] Set canvas.selection = ${canvas.selection}, activeTool = ${activeTool}`);

                // Reset cursor to default for the active tool
                if (activeTool === 'pan') {
                    this.setCursor('grab');
                } else if (activeTool === 'select') {
                    this.setCursor('default');
                } else {
                    this.setCursor('crosshair');
                }
            });

            // Object modification listener (fired when user finishes modifying an object)
            canvas.on('object:modified', async function(e) {
                resetInactivityTimer(); // Reset timer on user activity

                if (remoteUpdateGuard || !e.target) {
                    console.log('[object:modified] Skipped - remoteUpdateGuard');
                    return;
                }

                const updatedObject = e.target;

                // IMPORTANT: Handle activeSelection (multi-select group)
                if (updatedObject.type === 'activeSelection') {
                    const objects = updatedObject.getObjects();
                    console.log(`ğŸ“¦ [object:modified] Multi-select modified: ${objects.length} objects`);

                    // Temporarily discard the active selection to get absolute coordinates
                    // This converts relative group coordinates to absolute canvas coordinates
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();

                    console.log(`ğŸ“¦ [object:modified] Active selection discarded, objects now have absolute coords`);

                    // Now process each object with their updated absolute coordinates
                    for (const innerObj of objects) {
                        if (!innerObj.docId) {
                            console.warn(`[object:modified] Skipping object without docId`);
                            continue;
                        }

                        // Permission check for each object
                        if (userRole === 'student') {
                            if (!allowStudentEditAll && innerObj.authorUid !== auth.currentUser.uid) {
                                console.log(`[object:modified] Student skipping object from another user`);
                                continue;
                            }
                            if (isLocked) {
                                console.log(`[object:modified] Student is locked`);
                                continue;
                            }
                        }

                        // After discarding the selection, objects now have absolute coordinates
                        console.log(`ğŸ“¤ [object:modified] Object absolute position:`, {
                            docId: innerObj.docId,
                            type: innerObj.type,
                            position: `(${innerObj.left?.toFixed(0)}, ${innerObj.top?.toFixed(0)})`,
                            scale: `(${innerObj.scaleX?.toFixed(2)}, ${innerObj.scaleY?.toFixed(2)})`,
                            angle: innerObj.angle?.toFixed(0)
                        });

                        const objectRef = doc(db, "sessions", sessionId, "canvasObjects", innerObj.docId);
                        try {
                            // Get object data with absolute coordinates
                            const objData = innerObj.toObject();

                            if (innerObj.type === 'path' && Array.isArray(objData.path)) {
                                objData.path = JSON.stringify(objData.path);
                            }

                            await updateDoc(objectRef, { data: objData });
                            console.log(`âœ… [object:modified] Successfully updated ${innerObj.docId} with absolute coords`);

                            if (showAuthorNames && innerObj.authorNameText) {
                                removeAuthorNameText(innerObj);
                                addAuthorNameText(innerObj);
                            }
                        } catch (error) {
                            console.error(`âŒ [object:modified] Error updating object ${innerObj.docId}:`, error);
                        }
                    }

                    // Re-select the objects to restore the selection
                    if (objects.length > 0) {
                        const selection = new fabric.ActiveSelection(objects, {
                            canvas: canvas
                        });
                        canvas.setActiveObject(selection);
                        canvas.requestRenderAll();
                        console.log(`ğŸ“¦ [object:modified] Re-selected ${objects.length} objects`);
                    }

                    return;
                }

                // Single object modification
                if (!updatedObject.docId) {
                    console.log('[object:modified] Skipped - no docId');
                    return;
                }

                // Permission check: Teachers can modify all objects, students can modify based on allowStudentEditAll
                if (userRole === 'student') {
                    if (!allowStudentEditAll && updatedObject.authorUid !== auth.currentUser.uid) {
                        console.warn('âŒ [object:modified] Student cannot modify object created by another user', {
                            objectAuthorUid: updatedObject.authorUid,
                            currentUserUid: auth.currentUser.uid
                        });
                        return;
                    }
                    if (isLocked) {
                        console.warn('ğŸ”’ [object:modified] Student is locked');
                        return;
                    }
                }

                const objectRef = doc(db, "sessions", sessionId, "canvasObjects", updatedObject.docId);

                try {
                    const objData = updatedObject.toObject();
                    if (updatedObject.type === 'path' && Array.isArray(objData.path)) {
                        objData.path = JSON.stringify(objData.path);
                    }

                    console.log(`[object:modified] ğŸ“¤ Saving to Firestore (${userRole} modifying object):`, {
                        docId: updatedObject.docId,
                        type: updatedObject.type,
                        position: `(${objData.left?.toFixed(0)}, ${objData.top?.toFixed(0)})`,
                        scale: `(${objData.scaleX?.toFixed(2)}, ${objData.scaleY?.toFixed(2)})`,
                        angle: objData.angle?.toFixed(0),
                        isOwner: updatedObject.authorUid === auth.currentUser.uid
                    });

                    await updateDoc(objectRef, { data: objData });

                    console.log(`[object:modified] âœ… Successfully saved ${updatedObject.docId}`);

                    // Update author name text position if visible
                    if (showAuthorNames && updatedObject.authorNameText) {
                        removeAuthorNameText(updatedObject);
                        addAuthorNameText(updatedObject);
                    }
                } catch (error) {
                    console.error(`[object:modified] âŒ Error updating object:`, error);
                }
            });

            // Additional events for real-time updates during manipulation
            let scalingTimeout = null;
            let movingTimeout = null;
            let rotatingTimeout = null;

            // Update during scaling
            canvas.on('object:scaling', function(e) {
                if (remoteUpdateGuard) return;
                if (!e.target) return;

                const obj = e.target;

                // Skip activeSelection - handled in object:modified
                if (obj.type === 'activeSelection') {
                    return;
                }

                // Single object scaling
                if (!obj.docId) {
                    return;
                }

                // Permission check: Teachers can modify all objects, students can modify based on allowStudentEditAll
                if (userRole === 'student') {
                    if (!allowStudentEditAll && obj.authorUid !== auth.currentUser.uid) return;
                    if (isLocked) return;
                }

                // Update author name position if visible
                if (showAuthorNames && obj.authorNameText) {
                    removeAuthorNameText(obj);
                    addAuthorNameText(obj);
                }

                // Debounce the Firestore update
                clearTimeout(scalingTimeout);
                scalingTimeout = setTimeout(() => {
                    updateObjectInFirestore(obj);
                }, 200);
            });

            // Update during moving
            canvas.on('object:moving', function(e) {
                if (remoteUpdateGuard) return;
                if (!e.target) return;

                const obj = e.target;

                // IMPORTANT: Skip activeSelection (multi-select group)
                // Multi-select coordinates are handled in object:modified event
                if (obj.type === 'activeSelection') {
                    return;
                }

                // Single object movement
                // Critical check: Ensure object has docId for Firestore sync
                if (!obj.docId) {
                    console.warn('âš ï¸ [object:moving] Object missing docId - cannot sync to other devices!', {
                        objectType: obj.type,
                        hasAuthorUid: !!obj.authorUid,
                        objectsInMap: fabricObjects.size
                    });
                    return;
                }

                // Permission check: Teachers can modify all objects, students can only modify their own
                if (userRole === 'student') {
                    if (obj.authorUid !== auth.currentUser.uid) {
                        console.warn('âŒ [object:moving] Student cannot modify object created by another user', {
                            objectAuthorUid: obj.authorUid,
                            currentUserUid: auth.currentUser.uid
                        });
                        return;
                    }
                    if (isLocked) {
                        console.warn('ğŸ”’ [object:moving] Student is locked');
                        return;
                    }
                }

                console.log('ğŸ–±ï¸ [object:moving] User can move this object', {
                    docId: obj.docId,
                    type: obj.type,
                    position: `(${obj.left?.toFixed(0)}, ${obj.top?.toFixed(0)})`,
                    userRole: userRole,
                    isOwner: obj.authorUid === auth.currentUser.uid
                });

                // Update author name position if visible
                if (showAuthorNames && obj.authorNameText) {
                    removeAuthorNameText(obj);
                    addAuthorNameText(obj);
                }

                // Debounce the Firestore update
                clearTimeout(movingTimeout);
                movingTimeout = setTimeout(() => {
                    console.log('ğŸ“¤ [object:moving] Sending update to Firestore:', obj.docId);
                    updateObjectInFirestore(obj);
                }, 200);
            });

            // Update during rotating
            canvas.on('object:rotating', function(e) {
                if (remoteUpdateGuard) return;
                if (!e.target) return;

                const obj = e.target;

                // Skip activeSelection - handled in object:modified
                if (obj.type === 'activeSelection') {
                    return;
                }

                // Single object rotation
                if (!obj.docId) {
                    return;
                }

                // Permission check: Teachers can modify all objects, students can modify based on allowStudentEditAll
                if (userRole === 'student') {
                    if (!allowStudentEditAll && obj.authorUid !== auth.currentUser.uid) return;
                    if (isLocked) return;
                }

                // Update author name position if visible
                if (showAuthorNames && obj.authorNameText) {
                    removeAuthorNameText(obj);
                    addAuthorNameText(obj);
                }

                // Debounce the Firestore update
                clearTimeout(rotatingTimeout);
                rotatingTimeout = setTimeout(() => {
                    updateObjectInFirestore(obj);
                }, 200);
            });
            
            // Handle path creation from drawing mode
            canvas.on('path:created', async function(e) {
                console.log('âœ… [path:created] Event triggered', {
                    hasPath: !!e.path,
                    remoteUpdateGuard: remoteUpdateGuard,
                    userRole: userRole,
                    isLocked: isLocked,
                    isDrawingMode: canvas.isDrawingMode,
                    activeTool: activeTool
                });

                if (remoteUpdateGuard) {
                    console.log('[path:created] â­ï¸ Skipped - remoteUpdateGuard is true (remote update in progress)');
                    return;
                }

                if (!e.path) {
                    console.warn('[path:created] âŒ No path object in event');
                    return;
                }

                const newPath = e.path;

                // CRITICAL: Set fill to null to prevent black triangle appearance
                // Pen strokes should only have stroke, no fill
                newPath.set({
                    fill: null
                });

                console.log('[path:created] ğŸ¨ Path properties set:', {
                    stroke: newPath.stroke,
                    strokeWidth: newPath.strokeWidth,
                    fill: newPath.fill
                });

                // Set authorUid immediately for the path
                if (!newPath.authorUid && auth.currentUser) {
                    newPath.authorUid = auth.currentUser.uid;
                    console.log('[path:created] âœï¸ Set authorUid:', auth.currentUser.uid);
                }

                // Save to Firestore - each stroke is a separate object
                await addObjectToFirestore(newPath);

                console.log('[path:created] âœ… Path saved as individual object', {
                    hasDocId: !!newPath.docId,
                    docId: newPath.docId
                });
            });

            // Multi-selection event handlers - logs selection changes
            canvas.on('selection:created', function(e) {
                resetInactivityTimer(); // Reset timer on user activity
                console.log(`âœ… [selection:created] Selected ${e.selected ? e.selected.length : 0} object(s)`);
            });

            canvas.on('selection:updated', function(e) {
                resetInactivityTimer(); // Reset timer on user activity
                console.log(`âœ… [selection:updated] Selected ${e.selected ? e.selected.length : 0} object(s)`);
            });

            // Add listener for the slider UI
            if (zoomSlider) {
                zoomSlider.addEventListener('input', (e) => {
                    resetInactivityTimer(); // Reset timer on user activity
                    if (!canvas) return;
                    const zoom = parseFloat(e.target.value);
                    const center = canvas.getCenter();
                    canvas.zoomToPoint(new fabric.Point(center.left, center.top), zoom);
                    updateZoomUI();
                });
            }

            updateZoomUI(); // Set initial UI state
            activateTool('select');

            // Context menu handling
            let contextMenuTarget = null;
            let longPressTimer = null;
            const contextMenu = document.getElementById('context-menu');
            const changeColorBtn = document.getElementById('context-change-color');
            const duplicateTextBtn = document.getElementById('context-duplicate-text');
            const duplicateImageBtn = document.getElementById('context-duplicate-image');

            // Right-click and long-press handler
            canvas.on('mouse:down', function(opt) {
                const evt = opt.e;

                // Right-click detection
                if (evt.button === 2 || evt.which === 3) {
                    evt.preventDefault();
                    const target = canvas.findTarget(evt);
                    // Show context menu only for objects
                    if (target && (target.type === 'i-text' || target.type === 'image')) {
                        showContextMenu(target, evt.clientX, evt.clientY);
                    }
                }

                // Long-press detection for iPad
                if (evt.touches && evt.touches.length === 1) {
                    const target = canvas.findTarget(evt);
                    // Long-press on objects only
                    if (target && (target.type === 'i-text' || target.type === 'image')) {
                        longPressTimer = setTimeout(() => {
                            const touch = evt.touches[0];
                            showContextMenu(target, touch.clientX, touch.clientY);
                        }, 500); // 500ms for long press
                    }
                }
            });

            // Cancel long press on move or up
            canvas.on('mouse:move', function() {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            canvas.on('mouse:up', function() {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            // Prevent default context menu
            document.getElementById('whiteboard-canvas').addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Show context menu
            function showContextMenu(target, x, y) {
                contextMenuTarget = target;

                // Hide all menu items first
                changeColorBtn.classList.add('hidden');
                duplicateTextBtn.classList.add('hidden');
                duplicateImageBtn.classList.add('hidden');

                // Show appropriate menu item based on object type
                if (target && target.type === 'i-text') {
                    // Text object - show change color and duplicate
                    changeColorBtn.classList.remove('hidden');
                    duplicateTextBtn.classList.remove('hidden');
                } else if (target && target.type === 'image') {
                    // Image object - show duplicate only
                    duplicateImageBtn.classList.remove('hidden');
                }

                // Only show menu if there are visible items
                const hasVisibleItems = !changeColorBtn.classList.contains('hidden') ||
                                       !duplicateTextBtn.classList.contains('hidden') ||
                                       !duplicateImageBtn.classList.contains('hidden');

                if (hasVisibleItems) {
                    // Position and show menu
                    contextMenu.style.left = x + 'px';
                    contextMenu.style.top = y + 'px';
                    contextMenu.classList.remove('hidden');
                }
            }

            // Hide context menu
            function hideContextMenu() {
                contextMenu.classList.add('hidden');
                contextMenuTarget = null;
            }

            // Click outside to close
            document.addEventListener('click', (e) => {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                }
            });

            // Change text background color
            changeColorBtn.addEventListener('click', async () => {
                if (contextMenuTarget && contextMenuTarget.type === 'i-text') {
                    // Save reference before hiding menu
                    const targetObject = contextMenuTarget;

                    // Hide context menu
                    hideContextMenu();

                    // Show color picker
                    const selectedColor = await showColorPicker();

                    if (selectedColor === null) {
                        // User cancelled
                        return;
                    }

                    try {
                        // Update the background color
                        targetObject.set('backgroundColor', selectedColor);
                        canvas.requestRenderAll();

                        // Update in Firestore
                        if (targetObject.docId) {
                            const objectRef = doc(db, "sessions", sessionId, "canvasObjects", targetObject.docId);
                            const objData = targetObject.toJSON(['authorUid', 'page', 'docId']);
                            await updateDoc(objectRef, { data: objData });
                            console.log('[Change Color] Background color updated');
                            showToast('ä¾¿åˆ©è²¼èƒŒæ™¯è‰²å·²æ›´æ–°');
                        }
                    } catch (err) {
                        console.error('Failed to change color:', err);
                        showToast('æ›´æ”¹èƒŒæ™¯è‰²å¤±æ•—');
                    }
                }
            });

            // Duplicate text (sticky note)
            duplicateTextBtn.addEventListener('click', async () => {
                if (contextMenuTarget && contextMenuTarget.type === 'i-text') {
                    try {
                        // Get current page count from Firestore
                        const sessionRef = doc(db, "sessions", sessionId);
                        const sessionSnap = await getDoc(sessionRef);

                        if (!sessionSnap.exists()) {
                            showToast('ç„¡æ³•ç²å–åˆ†é è³‡è¨Š');
                            hideContextMenu();
                            return;
                        }

                        const pageCount = sessionSnap.data().metadata?.pageCount || 1;
                        const original = contextMenuTarget;

                        // Hide context menu first
                        hideContextMenu();

                        // Show page selector
                        const selectedPage = await showPageSelector(pageCount, currentPage);

                        if (selectedPage === null) {
                            // User cancelled
                            return;
                        }

                        // Clone the text object
                        original.clone(async (cloned) => {
                            // Set position and properties with slight offset to avoid overlap
                            cloned.set({
                                left: original.left + 15,
                                top: original.top + 15,
                                authorUid: auth.currentUser.uid,
                                page: selectedPage
                            });

                            // Serialize object data
                            const objData = cloned.toObject();

                            // Add to Firestore using the correct collection path
                            const newDocRef = doc(collection(db, "sessions", sessionId, "canvasObjects"));

                            // CRITICAL: Set docId and add to fabricObjects BEFORE setDoc
                            // This prevents Firestore listener from creating a duplicate
                            cloned.docId = newDocRef.id;
                            fabricObjects.set(newDocRef.id, cloned);

                            // If duplicating to current page, add to canvas immediately
                            if (selectedPage === currentPage) {
                                setupNewObject(cloned); // This already calls canvas.add internally
                                cloned.bringToFront(); // Bring duplicated text to front so it's selected first
                                canvas.requestRenderAll();
                            }

                            // Now save to Firestore (listener will skip because fabricObjects.has(docId) is true)
                            await setDoc(newDocRef, {
                                type: cloned.type,
                                data: objData,
                                authorUid: auth.currentUser.uid,
                                page: selectedPage
                            });

                            console.log(`[Duplicate Text] Text duplicated to page ${selectedPage}`);
                            showToast(`ä¾¿åˆ©è²¼å·²è¤‡è£½åˆ°åˆ†é  ${selectedPage}`);
                        });
                    } catch (err) {
                        console.error('Failed to duplicate text:', err);
                        showToast('è¤‡è£½ä¾¿åˆ©è²¼å¤±æ•—');
                    }
                }
            });

            // Duplicate image
            duplicateImageBtn.addEventListener('click', async () => {
                if (contextMenuTarget && contextMenuTarget.type === 'image') {
                    try {
                        // Get current page count from Firestore
                        const sessionRef = doc(db, "sessions", sessionId);
                        const sessionSnap = await getDoc(sessionRef);

                        if (!sessionSnap.exists()) {
                            showToast('ç„¡æ³•ç²å–åˆ†é è³‡è¨Š');
                            hideContextMenu();
                            return;
                        }

                        const pageCount = sessionSnap.data().metadata?.pageCount || 1;
                        const original = contextMenuTarget;

                        // Hide context menu first
                        hideContextMenu();

                        // Show page selector
                        const selectedPage = await showPageSelector(pageCount, currentPage);

                        if (selectedPage === null) {
                            // User cancelled
                            return;
                        }

                        // Clone the image
                        original.clone(async (cloned) => {
                            // Set position and properties with slight offset to avoid overlap
                            cloned.set({
                                left: original.left + 15,
                                top: original.top + 15,
                                authorUid: auth.currentUser.uid,
                                page: selectedPage
                            });

                            // Serialize object data
                            const objData = cloned.toObject();

                            // Add to Firestore using the correct collection path
                            const newDocRef = doc(collection(db, "sessions", sessionId, "canvasObjects"));

                            // CRITICAL: Set docId and add to fabricObjects BEFORE setDoc
                            // This prevents Firestore listener from creating a duplicate
                            cloned.docId = newDocRef.id;
                            fabricObjects.set(newDocRef.id, cloned);

                            // If duplicating to current page, add to canvas immediately
                            if (selectedPage === currentPage) {
                                setupNewObject(cloned); // This already calls canvas.add internally
                                cloned.bringToFront(); // Bring duplicated image to front so it's selected first
                                canvas.requestRenderAll();
                            }

                            // Now save to Firestore (listener will skip because fabricObjects.has(docId) is true)
                            await setDoc(newDocRef, {
                                type: cloned.type,
                                data: objData,
                                authorUid: auth.currentUser.uid,
                                page: selectedPage
                            });

                            console.log(`[Duplicate Image] Image duplicated to page ${selectedPage}`);
                            showToast(`åœ–ç‰‡å·²è¤‡è£½åˆ°åˆ†é  ${selectedPage}`);
                        });
                    } catch (err) {
                        console.error('Failed to duplicate image:', err);
                        showToast('è¤‡è£½åœ–ç‰‡å¤±æ•—');
                    }
                }
            });

            // Start inactivity timer for students
            if (userRole === 'student') {
                startInactivityTimer();
                console.log('[Inactivity] Timer started for student - 30 minutes timeout');
            }
        }

        // --- Inactivity Timer Functions (Student Auto-Logout) ---
        function startInactivityTimer() {
            // Clear any existing timer
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }

            // Set new timer for 30 minutes
            inactivityTimer = setTimeout(() => {
                console.log('[Inactivity] 30 minutes of inactivity detected - logging out student');
                showMessage('æ‚¨å·²ç¶“30åˆ†é˜æ²’æœ‰æ“ä½œï¼Œç³»çµ±è‡ªå‹•ç™»å‡ºã€‚');

                // Wait 2 seconds for message to be visible, then reload
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            }, INACTIVITY_TIMEOUT);
        }

        function resetInactivityTimer() {
            // Only reset for students
            if (userRole === 'student' && inactivityTimer) {
                clearTimeout(inactivityTimer);
                startInactivityTimer();
                // Uncomment for debugging: console.log('[Inactivity] Timer reset');
            }
        }

        // --- Toolbar & Tools Logic ---
        const toolButtons = document.querySelectorAll('.tool-btn');
        toolButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                resetInactivityTimer(); // Reset timer on user activity
                const tool = btn.dataset.tool;
                if (tool) activateTool(tool);
            });
        });

        function activateTool(tool) {
            console.log(`[activateTool] Switching to tool: ${tool}, previous tool: ${activeTool}`);
            console.log(`[activateTool] DEBUG: tool === 'delete'? ${tool === 'delete'}, tool type: ${typeof tool}`);
            const previousTool = activeTool;

            // IMPORTANT: Handle delete tool FIRST before discarding selection
            if (tool === 'delete') {
                console.log('ğŸ—‘ï¸ [activateTool] Delete tool activated - executing deletion');
                const activeObjects = canvas.getActiveObjects();
                console.log('ğŸ—‘ï¸ [activateTool] Selected objects before deletion:', activeObjects.length);
                deleteSelectedObjects();
                // After deletion, switch back to select tool
                console.log('ğŸ—‘ï¸ [activateTool] Deletion complete, switching back to select');
                activateTool('select');
                return;
            }

            console.log(`[activateTool] Not delete tool, continuing with normal flow`);

            activeTool = tool;

            document.getElementById('pen-options').classList.add('hidden');
            document.getElementById('note-options').classList.add('hidden');
            document.getElementById('shape-options').classList.add('hidden');

            toolButtons.forEach(b => b.classList.remove('active'));
            const currentBtn = document.querySelector(`.tool-btn[data-tool="${tool}"]`);
            if(currentBtn) currentBtn.classList.add('active');

            // Keep shapes button active if a shape tool is selected
            const shapeTools = ['rect', 'circle', 'arrow'];
            if (shapeTools.includes(tool)) {
                document.getElementById('shapes-btn').classList.add('active');
                // Don't show shape-options here - it should only show when clicking the shapes button
            } else {
                document.getElementById('shapes-btn').classList.remove('active');
                // Reset shapes button icon to default (circle) when switching to non-shape tool
                const shapesBtn = document.getElementById('shapes-btn');
                const currentSvg = shapesBtn.querySelector('svg');
                const defaultSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                defaultSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                defaultSvg.setAttribute('width', '24');
                defaultSvg.setAttribute('height', '24');
                defaultSvg.setAttribute('viewBox', '0 0 24 24');
                defaultSvg.setAttribute('fill', 'none');
                defaultSvg.setAttribute('stroke', 'currentColor');
                defaultSvg.setAttribute('stroke-width', '2');
                defaultSvg.setAttribute('stroke-linecap', 'round');
                defaultSvg.setAttribute('stroke-linejoin', 'round');
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '12');
                circle.setAttribute('cy', '12');
                circle.setAttribute('r', '10');
                defaultSvg.appendChild(circle);
                if (currentSvg) {
                    currentSvg.replaceWith(defaultSvg);
                }
            }

            if (!canvas) return;

            const isDrawingTool = ['pen', 'rect', 'circle', 'arrow'].includes(tool);
            const isSelectMode = tool === 'select';
            const isPanMode = tool === 'pan';

            canvas.isDrawingMode = tool === 'pen';
            // Enable multi-select box only for select mode
            canvas.selection = isSelectMode;

            console.log(`[activateTool] Set canvas.selection = ${isSelectMode} for tool: ${tool}`);

            // Set cursor based on tool
            if (isPanMode) {
                canvas.defaultCursor = 'grab';
            } else if (isSelectMode) {
                canvas.defaultCursor = 'default';
            } else {
                canvas.defaultCursor = 'crosshair';
            }

            // Discard any active selection when switching tools
            canvas.discardActiveObject();

            // Apply permissions to all objects
            const objects = canvas.getObjects();
            console.log(`[activateTool] Applying permissions to ${objects.length} objects`);
            objects.forEach(o => {
                applyObjectPermissions(o);
                o.setCoords(); // Update coordinates immediately
            });

            // Force canvas refresh
            canvas.requestRenderAll();

            // If switching TO select mode, do multiple refreshes to ensure newly created objects are selectable
            if (isSelectMode && previousTool !== 'select') {
                console.log(`[activateTool] Switching to select mode - applying additional refreshes`);

                // Ensure selection is enabled
                canvas.selection = true;

                // Immediate second refresh
                setTimeout(() => {
                    if (canvas && activeTool === 'select') {
                        canvas.selection = true;
                        canvas.forEachObject(o => {
                            applyObjectPermissions(o);
                            o.setCoords();
                        });
                        canvas.requestRenderAll();
                        console.log(`[activateTool] First delayed refresh complete, selection = ${canvas.selection}`);
                    }
                }, 50);

                // Third refresh for good measure (handles async object creation)
                setTimeout(() => {
                    if (canvas && activeTool === 'select') {
                        canvas.selection = true;
                        canvas.forEachObject(o => {
                            applyObjectPermissions(o);
                            o.setCoords();
                        });
                        canvas.requestRenderAll();
                        console.log(`[activateTool] Second delayed refresh complete, selection = ${canvas.selection}`);
                    }
                }, 150);
            }

            if (isDrawingTool) {
                document.getElementById('pen-options').classList.remove('hidden');
                // When activating pen tool, immediately apply the color and width from the toolbar
                if (tool === 'pen') {
                    const color = document.getElementById('pen-color').value;
                    const activeButton = document.querySelector('.pen-width-btn.active');
                    const width = activeButton ? parseInt(activeButton.dataset.width, 10) : 5;

                    // Ensure brush is initialized (important for iPad/touch devices)
                    if (!canvas.freeDrawingBrush) {
                        console.warn('[activateTool] ğŸ–Œï¸ Brush not initialized, creating new PencilBrush for iPad');
                        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                    }

                    canvas.freeDrawingBrush.color = color;
                    canvas.freeDrawingBrush.width = width;

                    console.log('âœï¸ [activateTool] Pen tool activated for iPad drawing', {
                        isDrawingMode: canvas.isDrawingMode,
                        brushColor: canvas.freeDrawingBrush.color,
                        brushWidth: canvas.freeDrawingBrush.width,
                        hasBrush: !!canvas.freeDrawingBrush
                    });

                    // Ensure drawing mode is active
                    if (!canvas.isDrawingMode) {
                        console.warn('[activateTool] âš ï¸ isDrawingMode was false, forcing to true for iPad drawing');
                        canvas.isDrawingMode = true;
                    }

                    // Double-check after setting
                    console.log('[activateTool] âœ… Final state check:', {
                        isDrawingMode: canvas.isDrawingMode,
                        activeTool: activeTool
                    });
                }
            } else if (tool === 'note') {
                document.getElementById('note-options').classList.remove('hidden');
            }
        }
        
        document.getElementById('pen-color').addEventListener('input', (e) => {
            if (canvas && canvas.isDrawingMode) canvas.freeDrawingBrush.color = e.target.value;
        });
        const penWidthButtons = document.querySelectorAll('#pen-options .pen-width-btn');
        penWidthButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const width = parseInt(e.currentTarget.dataset.width, 10);
                if (canvas && canvas.isDrawingMode) {
                    canvas.freeDrawingBrush.width = width;
                }
                penWidthButtons.forEach(b => b.classList.remove('active'));
                e.currentTarget.classList.add('active');
            });
        });
        // Set initial active state for pen width
        document.querySelector('.pen-width-btn[data-width="5"]').classList.add('active');
        
        function setupNewObject(obj) {
            // If authorUid is not set yet (local creation), set it
            if (!obj.authorUid && auth.currentUser) {
                obj.authorUid = auth.currentUser.uid;
            }
            applyObjectPermissions(obj); // Apply permissions
            canvas.add(obj);
            if (obj.type === 'image') {
                obj.sendToBack();
            }
            // Force update coordinates for touch devices
            obj.setCoords();
            canvas.requestRenderAll();
        }

        // Helper function to update merged pen strokes in Firestore
        async function updateMergedStrokeInFirestore(fabricObject) {
            if (!fabricObject || !fabricObject.docId) {
                console.warn('[updateMergedStrokeInFirestore] Object has no docId, skipping update');
                return;
            }

            try {
                const objectRef = doc(db, "sessions", sessionId, "canvasObjects", fabricObject.docId);
                const objData = fabricObject.toObject();

                // Handle path serialization for groups
                if (fabricObject.type === 'group') {
                    // Serialize each path in the group
                    objData.objects = objData.objects.map(obj => {
                        if (obj.type === 'path' && Array.isArray(obj.path)) {
                            obj.path = JSON.stringify(obj.path);
                        }
                        return obj;
                    });
                } else if (fabricObject.type === 'path' && Array.isArray(objData.path)) {
                    objData.path = JSON.stringify(objData.path);
                }

                console.log(`[updateMergedStrokeInFirestore] ğŸ’¾ Saving merged strokes:`, {
                    docId: fabricObject.docId,
                    type: fabricObject.type,
                    pathCount: fabricObject.type === 'group' ? fabricObject._objects.length : 1
                });

                await updateDoc(objectRef, {
                    data: objData,
                    type: fabricObject.type  // Update type in case it changed from path to group
                });

                console.log(`[updateMergedStrokeInFirestore] âœ… Merged strokes saved`);

                // Apply permissions and update display
                applyObjectPermissions(fabricObject);
                fabricObject.setCoords();
                canvas.requestRenderAll();

            } catch (error) {
                console.error('[updateMergedStrokeInFirestore] âŒ Error:', error);
            }
        }

        // Helper function to update object in Firestore (used for real-time updates during manipulation)
        async function updateObjectInFirestore(fabricObject) {
            if (!fabricObject || !fabricObject.docId) {
                console.warn('[updateObjectInFirestore] Object has no docId, skipping update');
                return;
            }

            try {
                const objectRef = doc(db, "sessions", sessionId, "canvasObjects", fabricObject.docId);

                // For path objects, include stroke/fill properties explicitly
                const propertiesToInclude = fabricObject.type === 'path'
                    ? ['stroke', 'strokeWidth', 'fill', 'strokeLineCap', 'strokeLineJoin', 'strokeMiterLimit']
                    : [];

                const objData = fabricObject.toObject(propertiesToInclude);

                if (fabricObject.type === 'path') {
                    // Ensure fill is explicitly set to null for stroke-only paths
                    if (!objData.fill || objData.fill === 'rgb(0,0,0)') {
                        objData.fill = null;
                    }

                    if (Array.isArray(objData.path)) {
                        objData.path = JSON.stringify(objData.path);
                    }
                }

                console.log(`[updateObjectInFirestore] ğŸ“¤ Real-time update:`, {
                    docId: fabricObject.docId,
                    type: fabricObject.type,
                    position: `(${objData.left?.toFixed(0)}, ${objData.top?.toFixed(0)})`,
                    scale: `(${objData.scaleX?.toFixed(2)}, ${objData.scaleY?.toFixed(2)})`,
                    angle: objData.angle?.toFixed(0),
                    isNewObject: fabricObject._justCreated
                });

                // CRITICAL FIX for iPad first object movement:
                // If the object was just created, use setDoc with merge instead of updateDoc
                // This handles the case where Firestore document might not be fully written yet
                if (fabricObject._justCreated) {
                    console.log(`[updateObjectInFirestore] ğŸ†• Object recently created, using setDoc with merge`);
                    await setDoc(objectRef, {
                        type: fabricObject.type,
                        data: objData,
                        authorUid: fabricObject.authorUid,
                        page: currentPage
                    }, { merge: true });
                } else {
                    await updateDoc(objectRef, { data: objData });
                }

                console.log(`[updateObjectInFirestore] âœ… Real-time update saved`);

                // Update author name text position if visible
                if (showAuthorNames && fabricObject.authorNameText) {
                    removeAuthorNameText(fabricObject);
                    addAuthorNameText(fabricObject);
                }
            } catch (error) {
                console.error('[updateObjectInFirestore] âŒ Error:', error);
                console.error('[updateObjectInFirestore] Error details:', {
                    code: error.code,
                    message: error.message,
                    docId: fabricObject.docId
                });

                // FALLBACK: If updateDoc fails (document might not exist yet), try setDoc
                if (error.code === 'not-found' || error.message?.includes('NOT_FOUND')) {
                    console.warn('[updateObjectInFirestore] ğŸ”„ Document not found, retrying with setDoc');
                    try {
                        const objectRef = doc(db, "sessions", sessionId, "canvasObjects", fabricObject.docId);
                        const objData = fabricObject.toObject();
                        if (fabricObject.type === 'path' && Array.isArray(objData.path)) {
                            objData.path = JSON.stringify(objData.path);
                        }
                        await setDoc(objectRef, {
                            type: fabricObject.type,
                            data: objData,
                            authorUid: fabricObject.authorUid,
                            page: currentPage
                        }, { merge: true });
                        console.log('[updateObjectInFirestore] âœ… Retry with setDoc successful');
                    } catch (retryError) {
                        console.error('[updateObjectInFirestore] âŒ Retry failed:', retryError);
                    }
                }
            }
        }

        async function addObjectToFirestore(fabricObject) {
            console.log('ğŸ¨ [addObjectToFirestore] Called from iPad/touch drawing', {
                hasObject: !!fabricObject,
                userRole: userRole,
                isLocked: isLocked,
                objectType: fabricObject?.type,
                currentPage: currentPage
            });

            if (!fabricObject) {
                console.error('[addObjectToFirestore] âŒ No fabricObject provided');
                return;
            }

            if (isLocked && userRole === 'student') {
                console.warn('[addObjectToFirestore] ğŸ”’ Student is locked, cannot add object');
                return;
            }

            try {
                // Set authorUid BEFORE any other operations
                if (!fabricObject.authorUid && auth.currentUser) {
                    fabricObject.authorUid = auth.currentUser.uid;
                    console.log('[addObjectToFirestore] âœï¸ Set authorUid:', auth.currentUser.uid);
                }

                console.log('[addObjectToFirestore] Step 1: ğŸ“‹ Preparing object data', {
                    authorUid: fabricObject.authorUid,
                    type: fabricObject.type,
                    hasPathData: fabricObject.type === 'path' && !!fabricObject.path
                });

                // Serialize object data with all necessary properties
                // For path objects, include stroke/fill properties explicitly
                const propertiesToInclude = fabricObject.type === 'path'
                    ? ['stroke', 'strokeWidth', 'fill', 'strokeLineCap', 'strokeLineJoin', 'strokeMiterLimit']
                    : [];

                const objData = fabricObject.toObject(propertiesToInclude);

                // For path objects, ensure path data is properly serialized
                if (fabricObject.type === 'path') {
                    // Ensure fill is explicitly set to null/empty for stroke-only paths
                    if (!objData.fill || objData.fill === 'rgb(0,0,0)') {
                        objData.fill = null;
                    }

                    if (Array.isArray(objData.path)) {
                        console.log(`[addObjectToFirestore] ğŸ“ Path has ${objData.path.length} points, converting to JSON string`);
                        objData.path = JSON.stringify(objData.path);
                    } else if (objData.path) {
                        console.warn(`[addObjectToFirestore] âš ï¸ Path is not an array:`, typeof objData.path);
                    } else {
                        console.error(`[addObjectToFirestore] âŒ Path object has no path data!`);
                    }

                    // Log detailed path info for debugging
                    console.log('[addObjectToFirestore] ğŸ“ Path details:', {
                        stroke: objData.stroke,
                        strokeWidth: objData.strokeWidth,
                        fill: objData.fill,
                        pathLength: Array.isArray(fabricObject.path) ? fabricObject.path.length : 'N/A'
                    });
                }

                console.log('[addObjectToFirestore] Step 2: ğŸ†” Generating Firestore document ID');

                // Generate a client-side ID to prevent race conditions with the snapshot listener
                const newDocRef = doc(collection(db, "sessions", sessionId, "canvasObjects"));

                // Set the ID on the local object and add it to the map BEFORE writing to Firestore
                fabricObject.docId = newDocRef.id;
                fabricObjects.set(newDocRef.id, fabricObject);

                // CRITICAL: Mark object as just created for iPad movement sync fix
                // This flag tells updateObjectInFirestore to use setDoc instead of updateDoc
                fabricObject._justCreated = true;
                console.log('[addObjectToFirestore] ğŸ†• Marked object as just created for safe updates');

                console.log(`[addObjectToFirestore] Step 3: ğŸ“¤ Saving to Firestore (docId: ${newDocRef.id}, page: ${currentPage})`);

                await setDoc(newDocRef, {
                    type: fabricObject.type,
                    data: objData,
                    authorUid: auth.currentUser.uid,
                    page: currentPage
                });

                console.log(`[addObjectToFirestore] âœ… Successfully saved to Firestore! Object will now sync to all users.`, {
                    docId: newDocRef.id,
                    type: fabricObject.type,
                    page: currentPage
                });

                // Remove the _justCreated flag after a delay to allow safe movement updates
                // This ensures the first few movement updates use setDoc instead of updateDoc
                setTimeout(() => {
                    if (fabricObject) {
                        fabricObject._justCreated = false;
                        console.log(`[addObjectToFirestore] â° Removed _justCreated flag for ${newDocRef.id}`);
                    }
                }, 1000); // 1 second should be enough for Firestore to fully commit the document

                if (showAuthorNames && fabricObject.authorUid) {
                    addAuthorNameText(fabricObject);
                }

                // Force refresh coordinates immediately after Firestore save
                fabricObject.setCoords();

                // IMPORTANT: Apply permissions based on CURRENT tool state
                // This ensures the object becomes selectable if we're already in select mode
                applyObjectPermissions(fabricObject);

                canvas.requestRenderAll();

                // Verify docId is set correctly
                if (!fabricObject.docId) {
                    console.error('[addObjectToFirestore] âŒ CRITICAL: docId missing after save!');
                } else {
                    console.log('[addObjectToFirestore] âœ… Object is ready for movement sync', {
                        docId: fabricObject.docId,
                        hasAuthorUid: !!fabricObject.authorUid,
                        inMap: fabricObjects.has(fabricObject.docId)
                    });
                }

                // Additional refresh to ensure the object is fully interactive
                setTimeout(() => {
                    if (canvas && fabricObject) {
                        applyObjectPermissions(fabricObject);
                        fabricObject.setCoords();
                        canvas.requestRenderAll();
                        console.log(`[addObjectToFirestore] ğŸ¯ Delayed refresh complete - object fully ready`);
                    }
                }, 100);

            } catch (error) {
                console.error("[addObjectToFirestore] âŒ Error:", error);
                console.error("[addObjectToFirestore] Error details:", {
                    message: error.message,
                    code: error.code,
                    stack: error.stack
                });
            }
        }

        function deleteSelectedObjects() {
            if (!canvas) {
                console.warn('âŒ [deleteSelectedObjects] Canvas not initialized');
                return;
            }

            const activeObjects = canvas.getActiveObjects();

            if (!activeObjects.length) {
                console.warn('âš ï¸ [deleteSelectedObjects] No objects selected');
                return;
            }

            console.log('ğŸ—‘ï¸ [deleteSelectedObjects] Attempting to delete objects', {
                count: activeObjects.length,
                userRole: userRole,
                objects: activeObjects.map(o => ({
                    type: o.type,
                    docId: o.docId,
                    authorUid: o.authorUid
                }))
            });

            let deletedCount = 0;
            let skippedCount = 0;

            activeObjects.forEach(obj => {
                // Permission check: Teachers can delete all objects, students can only delete their own
                const canDelete = userRole === 'teacher' ||
                                  (userRole === 'student' && obj.authorUid === auth.currentUser.uid);

                if (!canDelete) {
                    console.warn('âŒ [deleteSelectedObjects] Student cannot delete object created by another user', {
                        objectAuthorUid: obj.authorUid,
                        currentUserUid: auth.currentUser.uid,
                        objectType: obj.type
                    });
                    skippedCount++;
                    return; // Skip this object
                }

                console.log('âœ… [deleteSelectedObjects] Deleting object', {
                    docId: obj.docId,
                    type: obj.type,
                    authorUid: obj.authorUid,
                    userRole: userRole
                });

                if(obj.docId){
                    deleteDoc(doc(db, "sessions", sessionId, "canvasObjects", obj.docId));
                }
                // Also remove from local canvas immediately for better UX and to prevent race conditions.
                canvas.remove(obj);
                deletedCount++;
            });

            console.log(`ğŸ—‘ï¸ [deleteSelectedObjects] Deletion complete:`, {
                deleted: deletedCount,
                skipped: skippedCount,
                total: activeObjects.length
            });

            canvas.discardActiveObject();
            canvas.requestRenderAll();
        }

        let shape, isDown, origX, origY;
        function startDrawing(opt) {
            if (!canvas || !['rect', 'circle', 'arrow'].includes(activeTool)) return;

            isDown = true;
            const pointer = canvas.getPointer(opt.e);
            origX = pointer.x;
            origY = pointer.y;

            const penColorEl = document.getElementById('pen-color');
            const activeWidthBtn = document.querySelector('.pen-width-btn.active');

            const sharedProps = {
                left: origX,
                top: origY,
                originX: 'left',
                originY: 'top',
                fill: 'rgba(255, 255, 255, 0)',
                stroke: penColorEl ? penColorEl.value : '#3b82f6',
                strokeWidth: activeWidthBtn ? parseInt(activeWidthBtn.dataset.width, 10) : 3
            };
            if (activeTool === 'rect') {
                shape = new fabric.Rect({ ...sharedProps, width: 0, height: 0 });
            } else if (activeTool === 'circle') {
                shape = new fabric.Circle({ ...sharedProps, radius: 0 });
            } else if (activeTool === 'arrow') {
                // Create arrow as a line with arrow marker at the end
                shape = new fabric.Line([origX, origY, origX, origY], {
                    ...sharedProps,
                    originX: 'center',
                    originY: 'center'
                });
            }
            setupNewObject(shape);
        }

        function continueDrawing(opt) {
             if (!isDown || !shape) return;
             const pointer = canvas.getPointer(opt.e);

             if (activeTool === 'rect') {
                if (origX > pointer.x) { shape.set({ left: Math.abs(pointer.x) }); }
                if (origY > pointer.y) { shape.set({ top: Math.abs(pointer.y) }); }
                shape.set({ width: Math.abs(origX - pointer.x), height: Math.abs(origY - pointer.y) });
             } else if (activeTool === 'circle') {
                shape.set({ radius: Math.sqrt(Math.pow(origX - pointer.x, 2) + Math.pow(origY - pointer.y, 2)) / 2 });
             } else if (activeTool === 'arrow') {
                shape.set({ x2: pointer.x, y2: pointer.y });
             }
             canvas.requestRenderAll();
        }

        function stopDrawing() {
            if (isDown && shape) {
                // If drawing an arrow, replace the line with an arrow with angle bracket head at the end
                if (activeTool === 'arrow') {
                    const line = shape;
                    const x1 = line.x1, y1 = line.y1, x2 = line.x2, y2 = line.y2;

                    // Calculate arrow angle and distance
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

                    // Only create arrow if distance is meaningful
                    if (distance > 10) {
                        // Set arrowhead line length based on stroke width
                        // Thicker lines get longer arrowheads for better visibility
                        const baseLength = line.strokeWidth * 3;
                        const arrowheadLength = Math.max(baseLength, Math.min(baseLength * 1.5, distance / 4));

                        // Create main arrow line
                        const arrowLine = new fabric.Line([x1, y1, x2, y2], {
                            stroke: line.stroke,
                            strokeWidth: line.strokeWidth,
                            selectable: false
                        });

                        // Create right-angle arrowhead (two lines at 45 degrees)
                        // First line: from endpoint back at angle + 135 degrees (45 degrees from main line)
                        const angle1 = angle + (135 * Math.PI / 180);
                        const arrow1EndX = x2 + arrowheadLength * Math.cos(angle1);
                        const arrow1EndY = y2 + arrowheadLength * Math.sin(angle1);
                        const arrowLine1 = new fabric.Line([x2, y2, arrow1EndX, arrow1EndY], {
                            stroke: line.stroke,
                            strokeWidth: line.strokeWidth,
                            selectable: false
                        });

                        // Second line: from endpoint back at angle - 135 degrees (45 degrees from main line)
                        const angle2 = angle - (135 * Math.PI / 180);
                        const arrow2EndX = x2 + arrowheadLength * Math.cos(angle2);
                        const arrow2EndY = y2 + arrowheadLength * Math.sin(angle2);
                        const arrowLine2 = new fabric.Line([x2, y2, arrow2EndX, arrow2EndY], {
                            stroke: line.stroke,
                            strokeWidth: line.strokeWidth,
                            selectable: false
                        });

                        // Remove the temporary line and create arrow group
                        canvas.remove(shape);

                        // Create group with main line and two arrowhead lines
                        const arrowGroup = new fabric.Group([arrowLine, arrowLine1, arrowLine2], {
                            left: (x1 + x2) / 2,
                            top: (y1 + y2) / 2,
                            originX: 'center',
                            originY: 'center'
                        });

                        setupNewObject(arrowGroup);
                        shape = arrowGroup;
                    }
                }

                addObjectToFirestore(shape);
                shape = null;
            }
            isDown = false;
        }

        document.getElementById('note-options').addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.color) {
                addStickyNote(e.target.dataset.color);
            }
        });

        // Handle shapes button toggle
        document.getElementById('shapes-btn').addEventListener('click', () => {
            const shapeOptions = document.getElementById('shape-options');
            const isHidden = shapeOptions.classList.contains('hidden');

            // Toggle shape options visibility
            if (isHidden) {
                shapeOptions.classList.remove('hidden');
                document.getElementById('shapes-btn').classList.add('active');
            } else {
                shapeOptions.classList.add('hidden');
                document.getElementById('shapes-btn').classList.remove('active');
            }
        });

        // Handle shape selection
        document.getElementById('shape-options').addEventListener('click', (e) => {
            const shapeBtn = e.target.closest('.shape-btn');
            if (shapeBtn && shapeBtn.dataset.tool) {
                // Get the SVG from the clicked shape button
                const shapeSvg = shapeBtn.querySelector('svg').cloneNode(true);

                // Update the main shapes button icon
                const shapesBtn = document.getElementById('shapes-btn');
                const oldSvg = shapesBtn.querySelector('svg');
                if (oldSvg) {
                    oldSvg.replaceWith(shapeSvg);
                }

                // Close the shape options menu
                document.getElementById('shape-options').classList.add('hidden');

                // Activate the selected tool
                activateTool(shapeBtn.dataset.tool);
            }
        });

        function addStickyNote(color = '#FFFBEB') {
            if (!canvas) return;
            const center = canvas.getCenter();
            const vpCenter = fabric.util.transformPoint(center, canvas.viewportTransform);

            const note = new fabric.IText('é»æ­¤ç·¨è¼¯', {
                left: (center.left - canvas.viewportTransform[4]) / canvas.getZoom(),
                top: (center.top - canvas.viewportTransform[5]) / canvas.getZoom(),
                fontFamily: 'sans-serif',
                fill: '#1f2937',
                backgroundColor: color,
                padding: 10,
                fontSize: 24,
                width: 200,
                shadow: 'rgba(0,0,0,0.2) 2px 2px 5px'
            });
            setupNewObject(note);
            addObjectToFirestore(note);
            activateTool('select');
        }
        
        document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-input').click());
        document.getElementById('upload-pdf-btn').addEventListener('click', () => document.getElementById('pdf-input').click());

        document.getElementById('image-input').addEventListener('change', (e) => handleFile(e.target.files[0], 'image'));
        document.getElementById('pdf-input').addEventListener('change', (e) => handleFile(e.target.files[0], 'pdf'));

        async function handleFile(file, type) {
            if (!file) return;
            showLoading(true, 'æ­£åœ¨è™•ç†æª”æ¡ˆ...');
            try {
                if (type === 'image') {
                    const base64 = await resizeImage(file);
                    addImageToCanvas(base64);
                } else if (type === 'pdf') {
                    await renderPdfPreview(file);
                }
            } catch (error) {
                console.error(`Error handling file: ${type}`, error);
                showMessage(`è™•ç†${type === 'image' ? 'åœ–ç‰‡' : 'PDF'}æ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚`);
            } finally {
                document.getElementById('image-input').value = '';
                document.getElementById('pdf-input').value = '';
                showLoading(false);
            }
        }

        function resizeImage(file, maxWidth = 600) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvasEl = document.createElement('canvas');
                        const ctx = canvasEl.getContext('2d');
                        let { width, height } = img;
                        if (width > maxWidth) {
                            height = (maxWidth / width) * height;
                            width = maxWidth;
                        }
                        canvasEl.width = width;
                        canvasEl.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        resolve(canvasEl.toDataURL('image/jpeg', 0.7));
                    };
                    img.onerror = reject;
                    img.src = event.target.result;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }
        
        function addImageToCanvas(base64) {
            if (!canvas) return;
            console.log("addImageToCanvas called with base64 length:", base64 ? base64.length : "null"); // Debug log
            fabric.Image.fromURL(base64, (img) => {
                console.log("fabric.Image.fromURL callback executed. Image object:", img); // Debug log
                if (!img) {
                    console.error("fabric.Image.fromURL failed to create image object.");
                    return;
                }
                const center = canvas.getCenter();
                img.set({
                    left: (center.left - canvas.viewportTransform[4]) / canvas.getZoom(),
                    top: (center.top - canvas.viewportTransform[5]) / canvas.getZoom(),
                    scaleX: 1 / canvas.getZoom(),
                    scaleY: 1 / canvas.getZoom(),
                });
                setupNewObject(img);
                addObjectToFirestore(img);
                console.log("Image added to canvas and Firestore."); // Debug log
            }, { crossOrigin: 'anonymous' }); // Add crossOrigin for potential issues with data URLs
        }

        async function renderPdfPreview(file) {
            const modal = document.getElementById('pdf-preview-modal');
            const grid = document.getElementById('pdf-preview-grid');
            grid.innerHTML = '';
            modal.classList.remove('hidden');

            try {
                const fileReader = new FileReader();
                fileReader.onload = async function() {
                    const typedarray = new Uint8Array(this.result);
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;
                    const desiredWidth = 1024; // Set desired width to 1024px

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        
                        // Calculate scale to achieve the desired width
                        const viewportDefault = page.getViewport({ scale: 1 });
                        const scale = desiredWidth / viewportDefault.width;
                        const viewport = page.getViewport({ scale: scale });

                        const canvasEl = document.createElement('canvas');
                        const ctx = canvasEl.getContext('2d');
                        canvasEl.height = viewport.height;
                        canvasEl.width = viewport.width;

                        await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                        
                        const pageDiv = document.createElement('div');
                        pageDiv.className = 'relative border-2 border-transparent rounded-lg cursor-pointer p-1';
                        pageDiv.innerHTML = `
                            <img src="${canvasEl.toDataURL('image/jpeg', 0.7)}" class="w-full h-auto rounded-md shadow-sm">
                            <div class="absolute inset-0 bg-blue-500 bg-opacity-50 hidden items-center justify-center">
                                <svg class="w-12 h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                            </div>
                            <span class="absolute top-2 right-2 bg-gray-800 text-white text-xs rounded-full px-2 py-1">${i}</span>`;
                        pageDiv.dataset.pageNum = i;
                        pageDiv.addEventListener('click', () => {
                            pageDiv.classList.toggle('selected');
                            pageDiv.classList.toggle('border-blue-500');
                            pageDiv.querySelector('.absolute.inset-0').classList.toggle('hidden');
                            pageDiv.querySelector('.absolute.inset-0').classList.toggle('flex');
                        });
                        grid.appendChild(pageDiv);
                    }
                };
                fileReader.readAsArrayBuffer(file);
            } catch (error) {
                console.error("Error rendering PDF preview:", error);
                showMessage("è®€å–PDFæª”æ¡ˆå¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦æ­£å¸¸ã€‚");
                modal.classList.add('hidden');
            }
        }

        document.getElementById('insert-pdf-pages-btn').addEventListener('click', async () => {
            const selectedPageDivs = document.querySelectorAll('#pdf-preview-grid div.selected'); // Select the div with 'selected' class
            if (selectedPageDivs.length === 0) {
                showMessage('è«‹è‡³å°‘é¸æ“‡ä¸€å€‹é é¢ï¼');
                return;
            }
            showLoading(true, `æ­£åœ¨æ’å…¥ ${selectedPageDivs.length} å€‹é é¢...`);
            for (const pageDiv of selectedPageDivs) { // Iterate through the selected divs
                const img = pageDiv.querySelector('img'); // Get the img element inside the div
                if (img) {
                    try {
                        addImageToCanvas(img.src);
                    } catch (error) {
                        console.error("Error processing selected PDF page:", error);
                    }
                }
            }
            showLoading(false);
            document.getElementById('pdf-preview-modal').classList.add('hidden');
        });

        document.getElementById('close-pdf-modal').addEventListener('click', () => document.getElementById('pdf-preview-modal').classList.add('hidden'));

        document.getElementById('toggle-author-names-btn').addEventListener('click', async () => {
            if (userRole !== 'teacher') return; // Only teacher can toggle

            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const currentShowAuthorNames = sfDoc.data().metadata.showAuthorNames;
                    transaction.update(sessionRef, { "metadata.showAuthorNames": !currentShowAuthorNames });
                });
            } catch (e) {
                console.error("Toggle author names transaction failed: ", e);
            }
        });

        document.getElementById('allow-edit-all-btn').addEventListener('click', async () => {
            if (userRole !== 'teacher') return; // Only teacher can toggle

            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const currentAllowEditAll = sfDoc.data().metadata.allowStudentEditAll || false;
                    transaction.update(sessionRef, { "metadata.allowStudentEditAll": !currentAllowEditAll });
                });
            } catch (e) {
                console.error("Toggle allow edit all transaction failed: ", e);
            }
        });

        document.getElementById('lock-students-btn').addEventListener('click', async () => {
            const sessionRef = doc(db, "sessions", sessionId);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(sessionRef);
                    if (!sfDoc.exists()) throw "Document does not exist!";
                    const currentLockState = sfDoc.data().metadata.isLocked;
                    transaction.update(sessionRef, { "metadata.isLocked": !currentLockState });
                });
            } catch (e) {
                console.error("Lock transaction failed: ", e);
            }
        });

        // Export options modal
        const exportMenuBtn = document.getElementById('export-menu-btn');
        const exportOptionsModal = document.getElementById('export-options-modal');
        const exportOptionsCancelBtn = document.getElementById('export-options-cancel');

        // Show export options modal
        exportMenuBtn.addEventListener('click', () => {
            exportOptionsModal.classList.remove('hidden');
        });

        // Close modal when clicking cancel
        exportOptionsCancelBtn.addEventListener('click', () => {
            exportOptionsModal.classList.add('hidden');
        });

        // Close modal when clicking outside
        exportOptionsModal.addEventListener('click', (e) => {
            if (e.target === exportOptionsModal) {
                exportOptionsModal.classList.add('hidden');
            }
        });

        // Export JSON
        document.getElementById('export-json-btn').addEventListener('click', async () => {
            exportOptionsModal.classList.add('hidden');
            await exportWhiteboardAsJSON();
        });

        // Import JSON
        document.getElementById('import-json-btn').addEventListener('click', () => {
            exportOptionsModal.classList.add('hidden');
            document.getElementById('json-input').click();
        });

        // Handle JSON file import
        document.getElementById('json-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                await importWhiteboardFromJSON(file);
            }
            e.target.value = ''; // Reset input
        });

        // Download PDF
        document.getElementById('download-pdf-btn').addEventListener('click', async () => {
            exportOptionsModal.classList.add('hidden');
            await downloadCanvasAsPDF();
        });

        document.getElementById('leave-session-btn').addEventListener('click', () => {
            window.location.reload();
        });

        document.getElementById('close-session-btn').addEventListener('click', async () => {
            const confirmed = await showConfirm(
                'âš ï¸ è­¦å‘Šï¼šæ¸…ç©ºè³‡æ–™åº«',
                'æ­¤æ“ä½œå°‡æ°¸ä¹…åˆªé™¤æ•´å€‹è³‡æ–™åº«çš„æ‰€æœ‰ç™½æ¿å…§å®¹ï¼Œä¸”ç„¡æ³•å¾©åŸã€‚ç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ'
            );
            if (confirmed) {
                deleteAllSessions();
            }
        });

        // Export whiteboard as JSON
        async function exportWhiteboardAsJSON() {
            try {
                console.log('[åŒ¯å‡ºJSON] é–‹å§‹åŒ¯å‡ºç™½æ¿...');
                showLoading(true, 'æ­£åœ¨åŒ¯å‡ºç™½æ¿è³‡æ–™...');

                // Get session metadata
                const sessionRef = doc(db, "sessions", sessionId);
                const sessionSnap = await getDoc(sessionRef);

                if (!sessionSnap.exists()) {
                    showMessage('æ‰¾ä¸åˆ°ç™½æ¿è³‡æ–™');
                    showLoading(false);
                    return;
                }

                const metadata = sessionSnap.data().metadata;
                const pageCount = metadata.pageCount || 1;

                // Collect all objects from all pages
                const objectsRef = collection(db, "sessions", sessionId, "canvasObjects");
                const objectsSnap = await getDocs(objectsRef);

                const allObjects = [];
                objectsSnap.forEach(doc => {
                    const objData = doc.data();
                    const obj = {
                        id: doc.id,
                        ...objData
                    };

                    // Add author name if available in participantDataMap
                    if (objData.authorUid && participantDataMap.has(objData.authorUid)) {
                        obj.authorName = participantDataMap.get(objData.authorUid).name;
                    }

                    allObjects.push(obj);
                });

                // Create export data
                const exportData = {
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    sessionId: sessionId,
                    metadata: {
                        pageCount: pageCount,
                        isLocked: metadata.isLocked || false,
                        showAuthorNames: metadata.showAuthorNames || false,
                        allowStudentEditAll: metadata.allowStudentEditAll || false
                    },
                    objects: allObjects
                };

                // Convert to JSON and download
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `whiteboard_${sessionId}_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log(`[åŒ¯å‡ºJSON] æˆåŠŸåŒ¯å‡º ${allObjects.length} å€‹ç‰©ä»¶ï¼Œå…± ${pageCount} é `);
                showToast(`ç™½æ¿å·²åŒ¯å‡ºï¼åŒ…å« ${pageCount} é ï¼Œ${allObjects.length} å€‹ç‰©ä»¶`);
                showLoading(false);
            } catch (error) {
                console.error('[åŒ¯å‡ºJSON] éŒ¯èª¤:', error);
                showMessage(`åŒ¯å‡ºå¤±æ•—: ${error.message}`);
                showLoading(false);
            }
        }

        // Import whiteboard from JSON
        async function importWhiteboardFromJSON(file) {
            try {
                console.log('[åŒ¯å…¥JSON] é–‹å§‹åŒ¯å…¥ç™½æ¿...');

                // Confirm before clearing
                const confirmed = await showConfirm(
                    'âš ï¸ ç¢ºèªåŒ¯å…¥',
                    'åŒ¯å…¥å°‡æœƒæ¸…ç©ºç•¶å‰ç™½æ¿çš„æ‰€æœ‰å…§å®¹ï¼Œæ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚\n\næ˜¯å¦ç¹¼çºŒï¼Ÿ'
                );

                if (!confirmed) {
                    console.log('[åŒ¯å…¥JSON] ç”¨æˆ¶å–æ¶ˆåŒ¯å…¥');
                    return;
                }

                showLoading(true, 'æ­£åœ¨è®€å–æª”æ¡ˆ...');

                // Read file
                const text = await file.text();
                const importData = JSON.parse(text);

                console.log('[åŒ¯å…¥JSON] æª”æ¡ˆè®€å–æˆåŠŸï¼Œç‰ˆæœ¬:', importData.version);

                // Validate data
                if (!importData.metadata || !importData.objects) {
                    throw new Error('ç„¡æ•ˆçš„JSONæ ¼å¼');
                }

                showLoading(true, 'æ­£åœ¨æ¸…ç©ºç¾æœ‰å…§å®¹...');

                // Clear all existing objects
                const objectsRef = collection(db, "sessions", sessionId, "canvasObjects");
                const existingObjectsSnap = await getDocs(objectsRef);

                const deleteBatch = writeBatch(db);
                let deleteCount = 0;
                existingObjectsSnap.forEach(doc => {
                    deleteBatch.delete(doc.ref);
                    deleteCount++;
                });

                if (deleteCount > 0) {
                    await deleteBatch.commit();
                    console.log(`[åŒ¯å…¥JSON] å·²åˆªé™¤ ${deleteCount} å€‹ç¾æœ‰ç‰©ä»¶`);
                }

                showLoading(true, 'æ­£åœ¨åŒ¯å…¥æ–°å…§å®¹...');

                // Import new objects
                const importBatch = writeBatch(db);
                let importCount = 0;

                for (const obj of importData.objects) {
                    const newDocRef = doc(objectsRef, obj.id);
                    const { id, ...objData } = obj; // Remove id from data
                    importBatch.set(newDocRef, objData);
                    importCount++;
                }

                await importBatch.commit();
                console.log(`[åŒ¯å…¥JSON] å·²åŒ¯å…¥ ${importCount} å€‹ç‰©ä»¶`);

                // Update metadata (including showAuthorNames and isLocked)
                const sessionRef = doc(db, "sessions", sessionId);
                await updateDoc(sessionRef, {
                    "metadata.pageCount": importData.metadata.pageCount,
                    "metadata.isLocked": importData.metadata.isLocked || false,
                    "metadata.showAuthorNames": importData.metadata.showAuthorNames || false,
                    "metadata.allowStudentEditAll": importData.metadata.allowStudentEditAll || false
                });

                console.log(`[åŒ¯å…¥JSON] å·²æ›´æ–°metadata - åˆ†é æ•¸: ${importData.metadata.pageCount}, é–å®š: ${importData.metadata.isLocked}, é¡¯ç¤ºä½œè€…: ${importData.metadata.showAuthorNames}, é–‹æ”¾ç·¨è¼¯: ${importData.metadata.allowStudentEditAll}`);

                // Switch to first page
                if (currentPage !== 1) {
                    switchPage(1);
                }

                showToast(`ç™½æ¿åŒ¯å…¥æˆåŠŸï¼åŒ…å« ${importData.metadata.pageCount} é ï¼Œ${importCount} å€‹ç‰©ä»¶`);
                showLoading(false);
            } catch (error) {
                console.error('[åŒ¯å…¥JSON] éŒ¯èª¤:', error);
                showMessage(`åŒ¯å…¥å¤±æ•—: ${error.message}`);
                showLoading(false);
            }
        }

        async function downloadCanvasAsPDF() {
            try {
                console.log('[ä¸‹è¼‰PDF] é–‹å§‹ç”ŸæˆPDF...');
                showLoading(true, 'æ­£åœ¨æº–å‚™ä¸‹è¼‰...');

                // ç²å–ç¸½é æ•¸
                const sessionRef = doc(db, "sessions", sessionId);
                const sessionSnap = await getDoc(sessionRef);

                if (!sessionSnap.exists()) {
                    showMessage('æ‰¾ä¸åˆ°ç™½æ¿è³‡æ–™');
                    showLoading(false);
                    return;
                }

                const metadata = sessionSnap.data().metadata;
                const totalPages = metadata.pageCount || 1;
                const originalPage = currentPage; // ä¿å­˜ç•¶å‰é é¢

                console.log(`[ä¸‹è¼‰PDF] ç¸½å…± ${totalPages} é `);

                // è­¦å‘Šï¼šå¦‚æœé æ•¸éå¤š
                if (totalPages > 20) {
                    const confirmed = await showConfirm(
                        'âš ï¸ é æ•¸éå¤šè­¦å‘Š',
                        `æ­¤ç™½æ¿æœ‰ ${totalPages} é ï¼Œç”Ÿæˆ PDF å¯èƒ½éœ€è¦è¼ƒé•·æ™‚é–“ä¸”æª”æ¡ˆæœƒå¾ˆå¤§ã€‚\n\nå»ºè­°ï¼šå¦‚æœé æ•¸è¶…é 30 é ï¼Œè«‹è€ƒæ…®åˆ†æ‰¹ä¸‹è¼‰ã€‚\n\næ˜¯å¦ç¹¼çºŒï¼Ÿ`
                    );
                    if (!confirmed) {
                        showLoading(false);
                        return;
                    }
                }

                // ç¡¬æ€§é™åˆ¶ï¼šè¶…é 50 é 
                if (totalPages > 50) {
                    showMessage(`âš ï¸ é æ•¸éå¤š (${totalPages} é )\n\nç‚ºé¿å…ç€è¦½å™¨å´©æ½°ï¼Œå–®æ¬¡ä¸‹è¼‰é™åˆ¶ç‚º 50 é ã€‚\nè«‹è€ƒæ…®åˆªé™¤éƒ¨åˆ†é é¢å¾Œå†ä¸‹è¼‰ã€‚`);
                    showLoading(false);
                    return;
                }

                // ä¿å­˜ç•¶å‰é é¢çš„è¦–åœ–ç‹€æ…‹åˆ° pageViewStatesï¼ˆå¦‚æœé‚„æ²’ä¿å­˜ï¼‰
                if (!pageViewStates.has(currentPage)) {
                    pageViewStates.set(currentPage, {
                        zoom: canvas.getZoom(),
                        viewportTransform: canvas.viewportTransform.slice()
                    });
                }

                // è¨ˆç®—ç•«å¸ƒå°ºå¯¸ï¼ˆç”¨æ–¼è¨ˆç®—å¯è¦‹å€åŸŸï¼‰
                const canvasWidth = canvas.width;
                const canvasHeight = canvas.height;

                // åˆå§‹åŒ–jsPDFï¼ˆæš«æ™‚ä½¿ç”¨ç•«å¸ƒå°ºå¯¸ï¼Œç¨å¾Œæœƒæ ¹æ“šç¬¬ä¸€é èª¿æ•´ï¼‰
                const { jsPDF } = window.jspdf;
                let pdf = null;

                // ç§»é™¤ä½œè€…åç¨±é¡¯ç¤ºï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                const originalShowAuthorNames = showAuthorNames;
                if (showAuthorNames) {
                    canvas.forEachObject(obj => {
                        if (obj.authorUid) {
                            removeAuthorNameText(obj);
                        }
                    });
                    canvas.requestRenderAll();
                }

                // éæ­·æ¯ä¸€é 
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    showLoading(true, `æ­£åœ¨ç”Ÿæˆ PDF... (${pageNum}/${totalPages})`);
                    console.log(`[ä¸‹è¼‰PDF] æ­£åœ¨è™•ç†ç¬¬ ${pageNum} é ...`);

                    // åˆ‡æ›åˆ°è©²é é¢
                    if (pageNum !== currentPage) {
                        switchPage(pageNum);
                        // ç­‰å¾…é é¢è¼‰å…¥å®Œæˆ
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                    // ç²å–è©²é é¢çš„è¦–åœ–ç‹€æ…‹ï¼ˆå¦‚æœæœ‰ä¿å­˜çš„è©±ï¼Œå¦å‰‡ä½¿ç”¨é è¨­è¦–åœ–ï¼‰
                    let pageZoom, pageVPT;
                    if (pageViewStates.has(pageNum)) {
                        const savedState = pageViewStates.get(pageNum);
                        pageZoom = savedState.zoom;
                        pageVPT = savedState.viewportTransform.slice();
                        console.log(`[ä¸‹è¼‰PDF] ä½¿ç”¨ç¬¬ ${pageNum} é ä¿å­˜çš„è¦–åœ–ç‹€æ…‹ - Zoom: ${pageZoom.toFixed(2)}`);
                    } else {
                        // ä½¿ç”¨é»˜èªè¦–åœ–ï¼ˆzoom 1, ç„¡å¹³ç§»ï¼‰
                        pageZoom = 1;
                        pageVPT = [1, 0, 0, 1, 0, 0];
                        console.log(`[ä¸‹è¼‰PDF] ç¬¬ ${pageNum} é ç„¡ä¿å­˜çš„è¦–åœ–ç‹€æ…‹ï¼Œä½¿ç”¨é è¨­è¦–åœ–`);
                    }

                    // å¥—ç”¨è©²é é¢çš„è¦–åœ–ç‹€æ…‹
                    canvas.setViewportTransform(pageVPT);
                    canvas.setZoom(pageZoom);
                    canvas.requestRenderAll();

                    // ç­‰å¾…æ¸²æŸ“å®Œæˆ
                    await new Promise(resolve => setTimeout(resolve, 200));

                    console.log(`[ä¸‹è¼‰PDF] ç¬¬ ${pageNum} é  - è¢å¹•å°ºå¯¸: ${canvasWidth} x ${canvasHeight}, Zoom: ${pageZoom.toFixed(2)}`);

                    // åˆå§‹åŒ–PDFï¼ˆç¬¬ä¸€é æ™‚ï¼‰ï¼Œä½¿ç”¨è¢å¹•å°ºå¯¸
                    if (pageNum === 1) {
                        pdf = new jsPDF({
                            orientation: canvasWidth > canvasHeight ? 'landscape' : 'portrait',
                            unit: 'px',
                            format: [canvasWidth, canvasHeight]
                        });
                        console.log(`[ä¸‹è¼‰PDF] åˆå§‹åŒ–PDFï¼Œå°ºå¯¸: ${canvasWidth} x ${canvasHeight} (è¢å¹•å°ºå¯¸)`);
                    }

                    // æ“·å–ç•¶å‰å¯è¦‹å€åŸŸçš„åœ–ç‰‡ï¼ˆä½¿ç”¨è¼ƒä½è§£æåº¦é¿å…è¨˜æ†¶é«”æº¢å‡ºï¼‰
                    let imgData = null;
                    const attempts = [
                        { multiplier: 1, quality: 0.8, format: 'jpeg' },   // JPEG ä¸­å“è³ªï¼ˆé è¨­ï¼‰
                        { multiplier: 0.8, quality: 0.75, format: 'jpeg' }, // JPEG ä½å“è³ª
                        { multiplier: 0.6, quality: 0.7, format: 'jpeg' },  // æ›´ä½å“è³ª
                        { multiplier: 0.5, quality: 0.65, format: 'jpeg' }, // æœ€ä½å“è³ª
                        { multiplier: 0.4, quality: 0.6, format: 'jpeg' }   // è¶…ä½å“è³ªï¼ˆç·Šæ€¥å‚™ç”¨ï¼‰
                    ];

                    for (let i = 0; i < attempts.length; i++) {
                        try {
                            const config = attempts[i];
                            console.log(`[ä¸‹è¼‰PDF] å˜—è©¦é…ç½® ${i + 1}/${attempts.length}: multiplier=${config.multiplier}, quality=${config.quality}, format=${config.format}`);

                            // æš«æ™‚ä¿å­˜åŸå§‹èƒŒæ™¯è‰²
                            const originalBgColor = canvas.backgroundColor;

                            // è¨­ç½®ç‚ºç™½è‰²èƒŒæ™¯ä»¥ç¢ºä¿PDFæœ‰æ­£ç¢ºçš„èƒŒæ™¯
                            canvas.backgroundColor = '#FFFFFF';
                            canvas.requestRenderAll();

                            // ç›´æ¥æˆªå–è¢å¹•ç•«é¢ï¼ˆä¸æŒ‡å®šå€åŸŸï¼Œæˆªå–æ•´å€‹canvasï¼‰
                            imgData = canvas.toDataURL({
                                format: config.format,
                                quality: config.quality,
                                multiplier: config.multiplier
                            });

                            // æ¢å¾©åŸå§‹èƒŒæ™¯è‰²
                            canvas.backgroundColor = originalBgColor;
                            canvas.requestRenderAll();

                            console.log(`[ä¸‹è¼‰PDF] ç¬¬ ${pageNum} é åœ–ç‰‡ç”ŸæˆæˆåŠŸ (é…ç½® ${i + 1})`);
                            break; // æˆåŠŸå‰‡è·³å‡ºè¿´åœˆ
                        } catch (error) {
                            console.warn(`[ä¸‹è¼‰PDF] é…ç½® ${i + 1} å¤±æ•—:`, error.message);
                            if (i === attempts.length - 1) {
                                // æ‰€æœ‰å˜—è©¦éƒ½å¤±æ•—
                                throw new Error(`ç„¡æ³•ç”Ÿæˆç¬¬ ${pageNum} é çš„åœ–ç‰‡ï¼Œè«‹å˜—è©¦æ¸›å°‘ç•«å¸ƒå…§å®¹æˆ–ç¸®å°å¯è¦‹å€åŸŸ`);
                            }
                            // ç¹¼çºŒå˜—è©¦ä¸‹ä¸€å€‹é…ç½®
                        }
                    }

                    // æ·»åŠ åˆ°PDFï¼ˆç¬¬ä¸€é ä¸éœ€è¦addPageï¼‰
                    if (pageNum > 1) {
                        pdf.addPage([canvasWidth, canvasHeight]);
                    }

                    // å…ˆæ·»åŠ ç™½è‰²èƒŒæ™¯
                    pdf.setFillColor(255, 255, 255); // ç™½è‰²
                    pdf.rect(0, 0, canvasWidth, canvasHeight, 'F'); // å¡«æ»¿æ•´é 

                    // å°‡åœ–ç‰‡æ·»åŠ åˆ°PDFï¼ˆå¡«æ»¿æ•´é ï¼Œè‡ªå‹•æª¢æ¸¬æ ¼å¼ï¼‰
                    const imageFormat = imgData.startsWith('data:image/jpeg') ? 'JPEG' : 'PNG';
                    pdf.addImage(imgData, imageFormat, 0, 0, canvasWidth, canvasHeight);
                    console.log(`[ä¸‹è¼‰PDF] ç¬¬ ${pageNum} é å·²æ·»åŠ  (${canvasWidth}x${canvasHeight} px, æ ¼å¼: ${imageFormat})`);
                }

                // æ¢å¾©ä½œè€…åç¨±é¡¯ç¤º
                if (originalShowAuthorNames) {
                    canvas.forEachObject(obj => {
                        if (obj.authorUid) {
                            addAuthorNameText(obj);
                        }
                    });
                    canvas.requestRenderAll();
                }

                // åˆ‡å›åŸå§‹é é¢ä¸¦æ¢å¾©è¦–åœ–
                if (currentPage !== originalPage) {
                    switchPage(originalPage);
                } else {
                    // ç¢ºä¿è¦–åœ–ç‹€æ…‹æ­£ç¢ºï¼ˆæ¢å¾©åŸå§‹é é¢çš„è¦–åœ–ï¼‰
                    if (pageViewStates.has(originalPage)) {
                        const originalState = pageViewStates.get(originalPage);
                        canvas.setViewportTransform(originalState.viewportTransform);
                        canvas.setZoom(originalState.zoom);
                        canvas.requestRenderAll();

                        // æ›´æ–°ç¸®æ”¾UI
                        const zoomSlider = document.getElementById('zoom-slider');
                        const zoomLabel = document.getElementById('zoom-label');
                        if (zoomSlider) zoomSlider.value = originalState.zoom;
                        if (zoomLabel) zoomLabel.textContent = `${Math.round(originalState.zoom * 100)}%`;
                    }
                }

                // ç”Ÿæˆæª”åï¼ˆæ ¼å¼ï¼šç™½æ¿_YYYYMMDD_HHMMSS.pdfï¼‰
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const filename = `ç™½æ¿_${year}${month}${day}_${hours}${minutes}${seconds}.pdf`;

                showLoading(true, 'æ­£åœ¨ç”Ÿæˆ PDF æª”æ¡ˆ...');

                // ä¸‹è¼‰PDFï¼ˆä½¿ç”¨ Blob æ–¹å¼ä»¥é¿å…å­—ä¸²é•·åº¦é™åˆ¶ï¼‰
                try {
                    // å˜—è©¦ä½¿ç”¨æ›´å®‰å…¨çš„ Blob æ–¹å¼
                    const pdfBlob = pdf.output('blob');
                    const url = URL.createObjectURL(pdfBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                    console.log(`[ä¸‹è¼‰PDF] PDFå·²ä¸‹è¼‰: ${filename}`);
                    showLoading(false);
                    showMessage(`PDFå·²æˆåŠŸä¸‹è¼‰ï¼\næª”åï¼š${filename}\nç¸½å…± ${totalPages} é `);
                } catch (saveError) {
                    console.error('[ä¸‹è¼‰PDF] ä½¿ç”¨ Blob ä¸‹è¼‰å¤±æ•—ï¼Œå˜—è©¦å‚³çµ±æ–¹å¼:', saveError);

                    // å¦‚æœ Blob æ–¹å¼å¤±æ•—ï¼Œå˜—è©¦å‚³çµ±æ–¹å¼
                    try {
                        pdf.save(filename);
                        console.log(`[ä¸‹è¼‰PDF] PDFå·²ä¸‹è¼‰ (å‚³çµ±æ–¹å¼): ${filename}`);
                        showLoading(false);
                        showMessage(`PDFå·²æˆåŠŸä¸‹è¼‰ï¼\næª”åï¼š${filename}\nç¸½å…± ${totalPages} é `);
                    } catch (fallbackError) {
                        throw new Error('PDF æª”æ¡ˆéå¤§ï¼Œç„¡æ³•ä¸‹è¼‰ã€‚è«‹å˜—è©¦æ¸›å°‘é æ•¸æˆ–è¯çµ¡ç®¡ç†å“¡ã€‚');
                    }
                }

            } catch (error) {
                console.error('[ä¸‹è¼‰PDF] ç™¼ç”ŸéŒ¯èª¤:', error);
                showLoading(false);
                showMessage(`ä¸‹è¼‰PDFæ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}`);
            }
        }

        async function deleteAllSessions() {
            console.log('[æ¸…ç©ºè³‡æ–™åº«] é–‹å§‹æ¸…ç©ºæ•´å€‹Firebaseè³‡æ–™åº«...');
            showLoading(true, 'æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... (1/3)');

            try {
                // æ­¥é©Ÿ1: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨ï¼Œé¿å…åˆªé™¤éç¨‹ä¸­è§¸ç™¼é‡æ–°è¼‰å…¥
                console.log('[æ¸…ç©ºè³‡æ–™åº«] æ­¥é©Ÿ1: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨...');
                unsubscribes.forEach(unsub => {
                    try {
                        unsub();
                    } catch (e) {
                        console.warn('[æ¸…ç©ºè³‡æ–™åº«] å–æ¶ˆç›£è½å™¨æ™‚å‡ºéŒ¯:', e);
                    }
                });
                unsubscribes.length = 0;
                console.log('[æ¸…ç©ºè³‡æ–™åº«] æ‰€æœ‰ç›£è½å™¨å·²å–æ¶ˆ');

                showLoading(true, 'æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... (2/3)');

                // æ­¥é©Ÿ2: æŸ¥è©¢æ‰€æœ‰sessions
                console.log('[æ¸…ç©ºè³‡æ–™åº«] æ­¥é©Ÿ2: æŸ¥è©¢æ‰€æœ‰ç™½æ¿...');
                const sessionsRef = collection(db, "sessions");
                const sessionsSnap = await getDocs(sessionsRef);
                console.log(`[æ¸…ç©ºè³‡æ–™åº«] æ‰¾åˆ° ${sessionsSnap.size} å€‹ç™½æ¿`);

                // æ­¥é©Ÿ3: éæ­·æ¯å€‹sessionï¼Œåˆªé™¤å…¶å­é›†åˆå’Œä¸»æ–‡ä»¶
                let totalDeleted = 0;
                for (const sessionDoc of sessionsSnap.docs) {
                    const currentSessionId = sessionDoc.id;
                    console.log(`[æ¸…ç©ºè³‡æ–™åº«] æ­£åœ¨åˆªé™¤ç™½æ¿: ${currentSessionId}`);

                    // åˆªé™¤è©²sessionçš„æ‰€æœ‰participants
                    const participantsRef = collection(db, "sessions", currentSessionId, "participants");
                    const participantsSnap = await getDocs(participantsRef);
                    console.log(`  - æ‰¾åˆ° ${participantsSnap.size} å€‹åƒèˆ‡è€…`);

                    const deletePromises = [];
                    participantsSnap.forEach(doc => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });

                    // åˆªé™¤è©²sessionçš„æ‰€æœ‰canvasObjects
                    const objectsRef = collection(db, "sessions", currentSessionId, "canvasObjects");
                    const objectsSnap = await getDocs(objectsRef);
                    console.log(`  - æ‰¾åˆ° ${objectsSnap.size} å€‹ç•«å¸ƒç‰©ä»¶`);

                    objectsSnap.forEach(doc => {
                        deletePromises.push(deleteDoc(doc.ref));
                    });

                    // ç­‰å¾…æ‰€æœ‰å­é›†åˆæ–‡ä»¶åˆªé™¤å®Œæˆ
                    await Promise.all(deletePromises);

                    // åˆªé™¤sessionä¸»æ–‡ä»¶
                    await deleteDoc(sessionDoc.ref);
                    console.log(`  - ç™½æ¿ ${currentSessionId} å·²åˆªé™¤`);
                    totalDeleted++;

                    showLoading(true, `æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... å·²åˆªé™¤ ${totalDeleted}/${sessionsSnap.size} å€‹ç™½æ¿`);
                }

                showLoading(true, 'æ­£åœ¨æ¸…ç©ºè³‡æ–™åº«... (3/3)');
                console.log(`[æ¸…ç©ºè³‡æ–™åº«] æˆåŠŸåˆªé™¤ ${totalDeleted} å€‹ç™½æ¿ï¼Œè³‡æ–™åº«å·²å®Œå…¨æ¸…ç©º`);

                // é©—è­‰è³‡æ–™åº«æ˜¯å¦å·²æ¸…ç©º
                const verifySnap = await getDocs(sessionsRef);
                if (verifySnap.size > 0) {
                    console.error(`[æ¸…ç©ºè³‡æ–™åº«] è­¦å‘Š: ä»æœ‰ ${verifySnap.size} å€‹ç™½æ¿å­˜åœ¨ï¼`);
                    throw new Error(`åˆªé™¤é©—è­‰å¤±æ•—ï¼šä»æœ‰ ${verifySnap.size} å€‹ç™½æ¿å­˜åœ¨`);
                }

                console.log('[æ¸…ç©ºè³‡æ–™åº«] è³‡æ–™åº«å·²å®Œå…¨æ¸…ç©ºï¼Œå³å°‡é‡æ–°è¼‰å…¥é é¢...');
                showLoading(true, 'è³‡æ–™åº«æ¸…ç©ºæˆåŠŸï¼æ­£åœ¨é‡æ–°è¼‰å…¥...');

                // å»¶é²å¾Œé‡æ–°è¼‰å…¥é é¢
                setTimeout(() => {
                    window.location.reload();
                }, 1500);

            } catch (error) {
                console.error("[æ¸…ç©ºè³‡æ–™åº«] æ¸…ç©ºéç¨‹ç™¼ç”ŸéŒ¯èª¤:", error);
                console.error("[æ¸…ç©ºè³‡æ–™åº«] éŒ¯èª¤è©³æƒ…:", error.message, error.code);
                showLoading(false);
                showMessage(`æ¸…ç©ºè³‡æ–™åº«æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°æ—¥èªŒä¸¦ç¨å¾Œå†è©¦ã€‚`);
            }
        }

        async function deleteSession() {
            console.log(`[åˆªé™¤ç™½æ¿] é–‹å§‹åˆªé™¤ç™½æ¿ ID: ${sessionId}`);
            showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (1/4)');

            try {
                // æ­¥é©Ÿ1: åˆªé™¤æ‰€æœ‰åƒèˆ‡è€…è³‡æ–™
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ1: æŸ¥è©¢åƒèˆ‡è€…è³‡æ–™...');
                const participantsRef = collection(db, "sessions", sessionId, "participants");
                const participantsSnap = await getDocs(participantsRef);
                console.log(`[åˆªé™¤ç™½æ¿] æ‰¾åˆ° ${participantsSnap.size} å€‹åƒèˆ‡è€…`);

                if (participantsSnap.size > 0) {
                    const deletePromises = [];
                    participantsSnap.forEach(docSnapshot => {
                        deletePromises.push(deleteDoc(docSnapshot.ref));
                    });
                    await Promise.all(deletePromises);
                    console.log('[åˆªé™¤ç™½æ¿] æ‰€æœ‰åƒèˆ‡è€…å·²åˆªé™¤');
                }

                showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (2/4)');

                // æ­¥é©Ÿ2: åˆªé™¤æ‰€æœ‰ç•«å¸ƒç‰©ä»¶ï¼ˆåŒ…å«æ‰€æœ‰é é¢çš„åœ–ç‰‡ã€PDFã€ä¾¿åˆ©è²¼ã€ç¹ªåœ–ç­‰ï¼‰
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ2: æŸ¥è©¢ç•«å¸ƒç‰©ä»¶...');
                const objectsRef = collection(db, "sessions", sessionId, "canvasObjects");
                const objectsSnap = await getDocs(objectsRef);
                console.log(`[åˆªé™¤ç™½æ¿] æ‰¾åˆ° ${objectsSnap.size} å€‹ç•«å¸ƒç‰©ä»¶`);

                if (objectsSnap.size > 0) {
                    const deletePromises = [];
                    objectsSnap.forEach(docSnapshot => {
                        deletePromises.push(deleteDoc(docSnapshot.ref));
                    });
                    await Promise.all(deletePromises);
                    console.log('[åˆªé™¤ç™½æ¿] æ‰€æœ‰ç•«å¸ƒç‰©ä»¶å·²åˆªé™¤');
                }

                showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (3/4)');

                // æ­¥é©Ÿ3: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨ï¼Œé¿å…åˆªé™¤éç¨‹ä¸­è§¸ç™¼é‡æ–°è¼‰å…¥
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ3: å–æ¶ˆæ‰€æœ‰ç›£è½å™¨...');
                unsubscribes.forEach(unsub => {
                    try {
                        unsub();
                    } catch (e) {
                        console.warn('[åˆªé™¤ç™½æ¿] å–æ¶ˆç›£è½å™¨æ™‚å‡ºéŒ¯:', e);
                    }
                });
                unsubscribes.length = 0;
                console.log('[åˆªé™¤ç™½æ¿] æ‰€æœ‰ç›£è½å™¨å·²å–æ¶ˆ');

                showLoading(true, 'æ­£åœ¨åˆªé™¤ç™½æ¿è³‡æ–™... (4/4)');

                // æ­¥é©Ÿ4: æœ€å¾Œåˆªé™¤ä¸»è¦çš„sessionæ–‡ä»¶ï¼ˆåŒ…å«metadataï¼‰
                console.log('[åˆªé™¤ç™½æ¿] æ­¥é©Ÿ4: åˆªé™¤ä¸»sessionæ–‡ä»¶...');
                const sessionRef = doc(db, "sessions", sessionId);
                await deleteDoc(sessionRef);
                console.log('[åˆªé™¤ç™½æ¿] ä¸»sessionæ–‡ä»¶å·²åˆªé™¤');

                // é©—è­‰åˆªé™¤æ˜¯å¦æˆåŠŸ
                const verifyDoc = await getDoc(sessionRef);
                if (verifyDoc.exists()) {
                    console.error('[åˆªé™¤ç™½æ¿] éŒ¯èª¤: sessionæ–‡ä»¶ä»ç„¶å­˜åœ¨ï¼');
                    throw new Error('åˆªé™¤é©—è­‰å¤±æ•—ï¼šsessionæ–‡ä»¶ä»ç„¶å­˜åœ¨');
                }

                console.log(`[åˆªé™¤ç™½æ¿] ç™½æ¿ ${sessionId} å·²å®Œå…¨åˆªé™¤ï¼Œå³å°‡é‡æ–°è¼‰å…¥é é¢...`);
                showLoading(true, 'åˆªé™¤æˆåŠŸï¼æ­£åœ¨é‡æ–°è¼‰å…¥...');

                // å»¶é²ä¸€ä¸‹å†é‡æ–°è¼‰å…¥ï¼Œç¢ºä¿åˆªé™¤æ“ä½œå®Œå…¨å®Œæˆ
                setTimeout(() => {
                    window.location.reload();
                }, 1000);

            } catch (error) {
                console.error("[åˆªé™¤ç™½æ¿] åˆªé™¤éç¨‹ç™¼ç”ŸéŒ¯èª¤:", error);
                console.error("[åˆªé™¤ç™½æ¿] éŒ¯èª¤è©³æƒ…:", error.message, error.code);
                showLoading(false);
                showMessage(`åˆªé™¤ç™½æ¿æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message || 'æœªçŸ¥éŒ¯èª¤'}ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°æ—¥èªŒä¸¦ç¨å¾Œå†è©¦ã€‚`);
            }
        }

        async function deletePage(pageNum) {
            const sessionRef = doc(db, "sessions", sessionId);
            const sessionSnap = await getDoc(sessionRef);
            if (!sessionSnap.exists()) return;
            const pageCount = sessionSnap.data().metadata.pageCount || 1;

            if (pageCount <= 1) {
                showMessage("ç„¡æ³•åˆªé™¤æœ€å¾Œä¸€é ç•«å¸ƒã€‚");
                return;
            }

            const confirmed = await showConfirm(
                'âš ï¸ ç¢ºèªåˆªé™¤ç•«å¸ƒ',
                `æ‚¨ç¢ºå®šè¦æ°¸ä¹…åˆªé™¤ç¬¬ ${pageNum} é çš„æ‰€æœ‰å…§å®¹å—ï¼Ÿæ­¤å‹•ä½œç„¡æ³•å¾©åŸã€‚`
            );
            if (!confirmed) return;

            showLoading(true, `æ­£åœ¨åˆªé™¤ç¬¬ ${pageNum} é ...`);

            try {
                // Step 1: Delete all objects on the target page
                const objectsToDeleteQuery = query(collection(db, "sessions", sessionId, "canvasObjects"), where("page", "==", pageNum));
                const objectsToDeleteSnap = await getDocs(objectsToDeleteQuery);
                if (!objectsToDeleteSnap.empty) {
                    const deleteBatch = writeBatch(db);
                    objectsToDeleteSnap.forEach(doc => deleteBatch.delete(doc.ref));
                    await deleteBatch.commit();
                    console.log(`[Delete Page] Deleted ${objectsToDeleteSnap.size} objects from page ${pageNum}.`);
                }

                // Step 2: Re-number subsequent pages
                if (pageNum < pageCount) {
                    const objectsToShiftQuery = query(collection(db, "sessions", sessionId, "canvasObjects"), where("page", ">", pageNum));
                    const objectsToShiftSnap = await getDocs(objectsToShiftQuery);
                    
                    if (!objectsToShiftSnap.empty) {
                        let updateBatch = writeBatch(db);
                        let count = 0;
                        for (const doc of objectsToShiftSnap.docs) {
                            updateBatch.update(doc.ref, { page: doc.data().page - 1 });
                            count++;
                            if (count === 499) { // Commit in chunks
                                await updateBatch.commit();
                                updateBatch = writeBatch(db);
                                count = 0;
                            }
                        }
                        if (count > 0) { // Commit the final batch
                            await updateBatch.commit();
                        }
                        console.log(`[Delete Page] Re-numbered ${objectsToShiftSnap.size} objects.`);
                    }
                }

                // Step 3: Decrement pageCount in metadata
                await updateDoc(sessionRef, { "metadata.pageCount": pageCount - 1 });
                console.log(`[Delete Page] Decremented pageCount to ${pageCount - 1}.`);

                // Step 3.5: Update pageViewStates map
                // Remove the deleted page's view state
                pageViewStates.delete(pageNum);

                // Re-number view states for subsequent pages
                if (pageNum < pageCount) {
                    const newViewStates = new Map();
                    for (const [page, state] of pageViewStates.entries()) {
                        if (page < pageNum) {
                            // Keep pages before the deleted page as-is
                            newViewStates.set(page, state);
                        } else if (page > pageNum) {
                            // Shift pages after the deleted page down by 1
                            newViewStates.set(page - 1, state);
                        }
                    }
                    pageViewStates.clear();
                    for (const [page, state] of newViewStates.entries()) {
                        pageViewStates.set(page, state);
                    }
                    console.log(`[Delete Page] Updated pageViewStates after deletion`);
                }

                // Step 4: Switch to a valid page if the current one was deleted
                if (currentPage === pageNum) {
                    const newPage = Math.max(1, pageNum - 1);
                    switchPage(newPage);
                } else if (currentPage > pageNum) {
                    switchPage(currentPage - 1);
                }
                
                showMessage(`ç¬¬ ${pageNum} é å·²æˆåŠŸåˆªé™¤ã€‚`);

            } catch (error) {
                console.error("Error deleting page: ", error);
                showMessage(`åˆªé™¤é é¢æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        function handleLockState(locked) { // 'locked' here refers to the global lock state
            isLocked = locked; // Update global lock state tracker
            const lockIcon = document.getElementById('lock-icon');
            const lockMessage = document.getElementById('lock-message');

            // Teacher UI for global lock button
            if (lockIcon) {
                if (locked) {
                    lockIcon.classList.add('text-red-500');
                } else {
                    lockIcon.classList.remove('text-red-500');
                }
            }
            
            if (userRole === 'student') {
                // Determine combined lock state for student
                const combinedLockedState = isLocked || isCurrentUserIndividuallyLocked;

                // Show/hide lock message
                if (combinedLockedState) {
                    lockMessage.classList.remove('hidden');
                } else {
                    lockMessage.classList.add('hidden');
                }

                // Disable/enable toolbar buttons
                const toolbar = document.getElementById('toolbar');
                toolbar.querySelectorAll('button, input').forEach(el => {
                    if(!el.closest('#teacher-tools')) el.disabled = combinedLockedState;
                });
            }

            // Re-apply object permissions for all objects on canvas
            if (canvas) {
                canvas.forEachObject(o => applyObjectPermissions(o)); // applyObjectPermissions already checks combined state
                if(isLocked || isCurrentUserIndividuallyLocked) activateTool('select'); // Force select tool if any lock is active
                canvas.requestRenderAll();
            }
        }
        


        function showLoading(show, text = 'è™•ç†ä¸­...') {
            loadingText.textContent = text;
            if (show) {
                loadingOverlay.classList.remove('hidden');
            } else {
                loadingOverlay.classList.add('hidden');
            }
        }
        
        function applyObjectPermissions(obj) {
            let isSelectable = false;
            const debugInfo = {
                type: obj.type,
                hasAuthorUid: !!obj.authorUid,
                isOwner: obj.authorUid === auth.currentUser?.uid,
                userRole: userRole,
                activeTool: activeTool
            };

            if (userRole === 'teacher') {
                isSelectable = true;
            } else if (userRole === 'student') {
                // Check if current student is locked by teacher
                const currentParticipant = participantDataMap.get(auth.currentUser.uid);
                const isCurrentUserLockedByTeacher = currentParticipant ? currentParticipant.isLockedByTeacher : false;

                if (isLocked || isCurrentUserLockedByTeacher) { // If global lock or per-student lock is active
                    isSelectable = false;
                    debugInfo.reason = 'locked';
                } else { // If not locked, apply author-based permissions
                    // If allowStudentEditAll is true, students can edit all objects
                    if (allowStudentEditAll) {
                        isSelectable = true;
                        debugInfo.reason = 'edit all allowed';
                    } else if (obj.authorUid === auth.currentUser.uid) {
                        isSelectable = true;
                        debugInfo.reason = 'owner';
                    } else {
                        isSelectable = false;
                        debugInfo.reason = 'not owner';
                    }
                }
            }

            // Global override: if the current tool is not 'select', nothing is interactive.
            const beforeToolCheck = isSelectable;
            if (activeTool !== 'select') {
                isSelectable = false;
                debugInfo.toolOverride = true;
            }

            // Debug logging for student's own objects
            if (userRole === 'student' && obj.authorUid === auth.currentUser.uid && obj.type === 'path') {
                console.log(`[applyObjectPermissions] Student's path object:`, {
                    ...debugInfo,
                    beforeToolCheck,
                    finalSelectable: isSelectable,
                    objectId: obj.docId || 'no-docId'
                });
            }

            // Set properties and ensure they are applied
            obj.set({
                selectable: isSelectable,
                evented: isSelectable,
                hasControls: isSelectable,
                hasBorders: isSelectable,
                hoverCursor: isSelectable ? 'move' : 'default'
            });

            // Force the object to update its coordinates
            obj.setCoords();
        }

        function addAuthorNameText(obj) {
            if (!obj.authorUid) return;

            // Try to get author name from object first (imported from JSON), then from participantDataMap
            let authorName = obj.authorName; // From imported JSON
            if (!authorName && participantDataMap.has(obj.authorUid)) {
                authorName = participantDataMap.get(obj.authorUid).name;
            }

            // If still no author name, don't display
            if (!authorName) return;

            const text = new fabric.Text(authorName, {
                fontSize: 14,
                fill: '#0000FF', // Blue text
                backgroundColor: '#FFFF00', // Yellow background
                fontWeight: 'bold', // Bold text
                padding: 1,
                evented: false,
                selectable: false,
                hasControls: false,
                hasBorders: false,
                originX: 'right',
                originY: 'top',
                textBaseline: 'top', // Changed to 'top' to test CanvasTextBaseline issue
            });

            // Calculate position relative to the object's top-right corner
            text.set({
                left: obj.left + obj.getScaledWidth(),
                top: obj.top,
            });

            canvas.add(text);
            obj.authorNameText = text;
            canvas.bringToFront(text);
        }

        function removeAuthorNameText(obj) {
            if (obj.authorNameText) {
                canvas.remove(obj.authorNameText);
                obj.authorNameText = null;
            }
        }

        function openParticipantListModal() {
            if (userRole !== 'teacher') return; // Only teacher can open
            document.getElementById('participant-list-modal').classList.remove('hidden');
            renderParticipantList();
        }

        function closeParticipantListModal() {
            document.getElementById('participant-list-modal').classList.add('hidden');
        }

        function renderParticipantList() {
            const container = document.getElementById('participant-list-container');
            container.innerHTML = ''; // Clear previous list

            // Sort participants: teacher first, then students by name
            const sortedParticipants = Array.from(participantDataMap.values()).sort((a, b) => {
                if (a.role === 'teacher' && b.role !== 'teacher') return -1;
                if (a.role !== 'teacher' && b.role === 'teacher') return 1;
                return a.name.localeCompare(b.name);
            });

            sortedParticipants.forEach(p => {
                const participantDiv = document.createElement('div');
                participantDiv.className = 'flex items-center justify-between p-2 bg-gray-50 rounded-md shadow-sm';
                
                let statusText = '';
                let statusColor = 'text-gray-600';
                if (p.role === 'teacher') {
                    statusText = 'è€å¸«';
                    statusColor = 'text-blue-600';
                } else {
                    statusText = 'å­¸ç”Ÿ';
                    statusColor = 'text-green-600';
                    if (p.isLockedByTeacher) {
                        statusText += ' (å·²é–å®š)';
                        statusColor = 'text-red-600';
                    }
                }

                participantDiv.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="font-semibold">${p.name}</span>
                        <span class="${statusColor} text-sm">(${statusText})</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        ${p.role === 'student' ? `
                            <button data-uid="${p.uid}" class="toggle-lock-btn p-2 rounded-full ${p.isLockedByTeacher ? 'bg-red-500 text-white' : 'bg-gray-200 text-gray-700'} hover:opacity-80" title="${p.isLockedByTeacher ? 'è§£é–å­¸ç”Ÿ' : 'é–å®šå­¸ç”Ÿ'}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${p.isLockedByTeacher ? '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>' : '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/>'}</svg>
                            </button>
                            <button data-uid="${p.uid}" class="kick-student-btn p-2 rounded-full bg-red-500 text-white hover:opacity-80" title="è¸¢å‡ºå­¸ç”Ÿ">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="17" y1="17" x2="22" y2="22"></line><line x1="22" y1="17" x2="17" y2="22"></line></svg>
                            </button>
                        ` : ''}
                    </div>
                `;
                container.appendChild(participantDiv);
            });

            // Add event listeners for new buttons
            container.querySelectorAll('.toggle-lock-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const uid = e.currentTarget.dataset.uid;
                    toggleStudentLock(uid);
                });
            });
            container.querySelectorAll('.kick-student-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const uid = e.currentTarget.dataset.uid;
                    kickParticipant(uid);
                });
            });
        }

        async function toggleStudentLock(uid) {
            const participantRef = doc(db, "sessions", sessionId, "participants", uid);
            try {
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(participantRef);
                    if (!sfDoc.exists()) throw "Participant does not exist!";
                    const currentLockState = sfDoc.data().isLockedByTeacher;
                    transaction.update(participantRef, { "isLockedByTeacher": !currentLockState });
                });
            } catch (e) {
                console.error("Toggle student lock transaction failed: ", e);
            }
        }

        async function kickParticipant(uid) {
            const participantData = participantDataMap.get(uid);
            const studentName = participantData ? participantData.name : 'æ­¤å­¸ç”Ÿ';

            const confirmed = await showConfirm(
                'è¸¢å‡ºå­¸ç”Ÿ',
                `ç¢ºå®šè¦å°‡ "${studentName}" è¸¢å‡ºç™½æ¿å—ï¼Ÿ`
            );
            if (!confirmed) return;

            const participantRef = doc(db, "sessions", sessionId, "participants", uid);
            try {
                await deleteDoc(participantRef);
            } catch (e) {
                console.error("Kick participant failed: ", e);
                showMessage("è¸¢å‡ºå­¸ç”Ÿå¤±æ•—ã€‚");
            }
        }

        function resizeCanvas() {
            if (canvas) {
                canvas.setWidth(window.innerWidth);
                canvas.setHeight(window.innerHeight);
                canvas.renderAll();
            }
        }

        window.addEventListener('keydown', (e) => {
            resetInactivityTimer(); // Reset timer on user activity

            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.isContentEditable || activeEl.tagName === 'TEXTAREA')) return;

            if (e.key.toLowerCase() === 'p' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
            }

            switch(e.key.toLowerCase()) {
                case 'v': activateTool('select'); break;
                case 'p': activateTool('pen'); break;
                case 'r': activateTool('rect'); break;
                case 'c': activateTool('circle'); break;
                case 's':
                    // Toggle shapes menu
                    document.getElementById('shapes-btn').click();
                    break;
                case 'h': activateTool('pan'); break;
                case 'n': activateTool('note'); break;
                case 'i': document.getElementById('upload-image-btn').click(); break;
                case 'f': document.getElementById('upload-pdf-btn').click(); break;
                case 'delete':
                case 'backspace':
                    deleteSelectedObjects();
                    break;
            }
        });

        // Event listeners for participant list modal
        document.getElementById('participant-display').addEventListener('click', openParticipantListModal);
        document.getElementById('close-participant-list-modal').addEventListener('click', closeParticipantListModal);
        document.getElementById('refresh-participant-list-btn').addEventListener('click', renderParticipantList);

        initApp();

    </script>
</body>
</html>

